<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="Gst" version="1.0"/>
  <include name="GstBase" version="1.0"/>
  <include name="GstTag" version="1.0"/>
  <package name="gstreamer-audio-1.0"/>
  <c:include name="gst/audio/audio.h"/>
  <namespace name="GstAudio"
             version="1.0"
             shared-library="/Library/Frameworks/GStreamer.framework/Versions/1.0/lib/libgstaudio-1.0.0.dylib"
             c:identifier-prefixes="Gst"
             c:symbol-prefixes="gst">
    <constant name="AUDIO_CHANNELS_RANGE"
              value="(int) [ 1, max ]"
              c:type="GST_AUDIO_CHANNELS_RANGE">
      <doc xml:space="preserve">Maximum range of allowed channels, for use in template caps strings.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_DECODER_MAX_ERRORS"
              value="10"
              c:type="GST_AUDIO_DECODER_MAX_ERRORS">
      <doc xml:space="preserve">Default maximum number of errors tolerated before signaling error.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AUDIO_DECODER_SINK_NAME"
              value="sink"
              c:type="GST_AUDIO_DECODER_SINK_NAME">
      <doc xml:space="preserve">The name of the templates for the sink pad.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_DECODER_SRC_NAME"
              value="src"
              c:type="GST_AUDIO_DECODER_SRC_NAME">
      <doc xml:space="preserve">The name of the templates for the source pad.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_DEF_CHANNELS"
              value="2"
              c:type="GST_AUDIO_DEF_CHANNELS">
      <doc xml:space="preserve">Standard number of channels used in consumer audio.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AUDIO_DEF_FORMAT"
              value="S16LE"
              c:type="GST_AUDIO_DEF_FORMAT">
      <doc xml:space="preserve">Standard format used in consumer audio.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_DEF_RATE" value="44100" c:type="GST_AUDIO_DEF_RATE">
      <doc xml:space="preserve">Standard sampling rate used in consumer audio.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AUDIO_ENCODER_SINK_NAME"
              value="sink"
              c:type="GST_AUDIO_ENCODER_SINK_NAME">
      <doc xml:space="preserve">the name of the templates for the sink pad</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_ENCODER_SRC_NAME"
              value="src"
              c:type="GST_AUDIO_ENCODER_SRC_NAME">
      <doc xml:space="preserve">the name of the templates for the source pad</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_FORMATS_ALL"
              value=" { S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE }"
              c:type="GST_AUDIO_FORMATS_ALL">
      <doc xml:space="preserve">List of all audio formats, for use in template caps strings.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_RATE_RANGE"
              value="(int) [ 1, max ]"
              c:type="GST_AUDIO_RATE_RANGE">
      <doc xml:space="preserve">Maximum range of allowed sample rates, for use in template caps strings.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="AudioBaseSink"
           c:symbol-prefix="audio_base_sink"
           c:type="GstAudioBaseSink"
           parent="GstBase.BaseSink"
           glib:type-name="GstAudioBaseSink"
           glib:get-type="gst_audio_base_sink_get_type"
           glib:type-struct="AudioBaseSinkClass">
      <doc xml:space="preserve">This is the base class for audio sinks. Subclasses need to implement the
::create_ringbuffer vmethod. This base class will then take care of
writing samples to the ringbuffer, synchronisation, clipping and flushing.</doc>
      <virtual-method name="create_ringbuffer" invoker="create_ringbuffer">
        <doc xml:space="preserve">Create and return the #GstAudioRingBuffer for @sink. This function will
call the ::create_ringbuffer vmethod and will set @sink as the parent of
the returned buffer (see gst_object_set_parent()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The new ringbuffer of @sink.</doc>
          <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink.</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="payload">
        <return-value transfer-ownership="full">
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="create_ringbuffer"
              c:identifier="gst_audio_base_sink_create_ringbuffer">
        <doc xml:space="preserve">Create and return the #GstAudioRingBuffer for @sink. This function will
call the ::create_ringbuffer vmethod and will set @sink as the parent of
the returned buffer (see gst_object_set_parent()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The new ringbuffer of @sink.</doc>
          <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink.</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alignment_threshold"
              c:identifier="gst_audio_base_sink_get_alignment_threshold">
        <doc xml:space="preserve">Get the current alignment threshold, in nanoseconds, used by @sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current alignment threshold used by @sink.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_discont_wait"
              c:identifier="gst_audio_base_sink_get_discont_wait">
        <doc xml:space="preserve">Get the current discont wait, in nanoseconds, used by @sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current discont wait used by @sink.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_drift_tolerance"
              c:identifier="gst_audio_base_sink_get_drift_tolerance">
        <doc xml:space="preserve">Get the current drift tolerance, in microseconds, used by @sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current drift tolerance used by @sink.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_provide_clock"
              c:identifier="gst_audio_base_sink_get_provide_clock">
        <doc xml:space="preserve">Queries whether @sink will provide a clock or not. See also
gst_audio_base_sink_set_provide_clock.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @sink will provide a clock.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_slave_method"
              c:identifier="gst_audio_base_sink_get_slave_method">
        <doc xml:space="preserve">Get the current slave method used by @sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current slave method used by @sink.</doc>
          <type name="AudioBaseSinkSlaveMethod"
                c:type="GstAudioBaseSinkSlaveMethod"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="report_device_failure"
              c:identifier="gst_audio_base_sink_report_device_failure"
              version="1.6">
        <doc xml:space="preserve">Informs this base class that the audio output device has failed for
some reason, causing a discontinuity (for example, because the device
recovered from the error, but lost all contents of its ring buffer).
This function is typically called by derived classes, and is useful
for the custom slave method.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_alignment_threshold"
              c:identifier="gst_audio_base_sink_set_alignment_threshold">
        <doc xml:space="preserve">Controls the sink's alignment threshold.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
          <parameter name="alignment_threshold" transfer-ownership="none">
            <doc xml:space="preserve">the new alignment threshold in nanoseconds</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_custom_slaving_callback"
              c:identifier="gst_audio_base_sink_set_custom_slaving_callback"
              version="1.6">
        <doc xml:space="preserve">Sets the custom slaving callback. This callback will
be invoked if the slave-method property is set to
GST_AUDIO_BASE_SINK_SLAVE_CUSTOM and the audio sink
receives and plays samples.

Setting the callback to NULL causes the sink to
behave as if the GST_AUDIO_BASE_SINK_SLAVE_NONE
method were used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">a #GstAudioBaseSinkCustomSlavingCallback</doc>
            <type name="AudioBaseSinkCustomSlavingCallback"
                  c:type="GstAudioBaseSinkCustomSlavingCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">user data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called when user_data becomes unused</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_discont_wait"
              c:identifier="gst_audio_base_sink_set_discont_wait">
        <doc xml:space="preserve">Controls how long the sink will wait before creating a discontinuity.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
          <parameter name="discont_wait" transfer-ownership="none">
            <doc xml:space="preserve">the new discont wait in nanoseconds</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_drift_tolerance"
              c:identifier="gst_audio_base_sink_set_drift_tolerance">
        <doc xml:space="preserve">Controls the sink's drift tolerance.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
          <parameter name="drift_tolerance" transfer-ownership="none">
            <doc xml:space="preserve">the new drift tolerance in microseconds</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_provide_clock"
              c:identifier="gst_audio_base_sink_set_provide_clock">
        <doc xml:space="preserve">Controls whether @sink will provide a clock or not. If @provide is %TRUE,
gst_element_provide_clock() will return a clock that reflects the datarate
of @sink. If @provide is %FALSE, gst_element_provide_clock() will return
NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
          <parameter name="provide" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_slave_method"
              c:identifier="gst_audio_base_sink_set_slave_method">
        <doc xml:space="preserve">Controls how clock slaving will be performed in @sink.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">the new slave method</doc>
            <type name="AudioBaseSinkSlaveMethod"
                  c:type="GstAudioBaseSinkSlaveMethod"/>
          </parameter>
        </parameters>
      </method>
      <property name="alignment-threshold"
                writable="1"
                transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="buffer-time" writable="1" transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="can-activate-pull"
                writable="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="discont-wait" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A window of time in nanoseconds to wait before creating a discontinuity as
a result of breaching the drift-tolerance.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="drift-tolerance" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Controls the amount of time in microseconds that clocks are allowed
to drift before resynchronisation happens.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="latency-time" writable="1" transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="provide-clock" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="slave-method" writable="1" transfer-ownership="none">
        <type name="AudioBaseSinkSlaveMethod"/>
      </property>
      <field name="element">
        <type name="GstBase.BaseSink" c:type="GstBaseSink"/>
      </field>
      <field name="ringbuffer">
        <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
      </field>
      <field name="buffer_time">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="latency_time">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="next_sample">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="provided_clock">
        <type name="Gst.Clock" c:type="GstClock*"/>
      </field>
      <field name="eos_rendering">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AudioBaseSinkPrivate" c:type="GstAudioBaseSinkPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioBaseSinkClass"
            c:type="GstAudioBaseSinkClass"
            glib:is-gtype-struct-for="AudioBaseSink">
      <doc xml:space="preserve">#GstAudioBaseSink class. Override the vmethod to implement
functionality.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class.</doc>
        <type name="GstBase.BaseSinkClass" c:type="GstBaseSinkClass"/>
      </field>
      <field name="create_ringbuffer">
        <callback name="create_ringbuffer">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The new ringbuffer of @sink.</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <doc xml:space="preserve">a #GstAudioBaseSink.</doc>
              <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="payload">
        <callback name="payload">
          <return-value transfer-ownership="full">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="AudioBaseSinkCustomSlavingCallback"
              c:type="GstAudioBaseSinkCustomSlavingCallback"
              version="1.6">
      <doc xml:space="preserve">This function is set with gst_audio_base_sink_set_custom_slaving_callback()
and is called during playback. It receives the current time of external and
internal clocks, which the callback can then use to apply any custom
slaving/synchronization schemes. The external clock is the sink's element clock,
the internal one is the internal audio clock. The internal audio clock's
calibration is applied to the timestamps before they are passed to the
callback. The difference between etime and itime is the skew; how much
internal and external clock lie apart from each other. A skew of 0 means
both clocks are perfectly in sync. itime &gt; etime means the external clock
is going slower, while itime &lt; etime means it is going faster than the
internal clock. etime and itime are always valid timestamps, except for when
discont is set to TRUE.
requested_skew is an output value the callback can write to. It informs the sink
of whether or not it should move the playout pointer, and if so, by how much.
This pointer is only NULL if discont is true; otherwise, it is safe to write
to *requested_skew. The default skew is 0.

The sink may experience discontinuities. If one happens, discont is TRUE,
itime, etime are set to GST_CLOCK_TIME_NONE, and requested_skew is NULL.
This makes it possible to reset custom clock slaving algorithms when a
discontinuity happens.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="sink" transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioBaseSink</doc>
          <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
        </parameter>
        <parameter name="etime" transfer-ownership="none">
          <doc xml:space="preserve">external clock time</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </parameter>
        <parameter name="itime" transfer-ownership="none">
          <doc xml:space="preserve">internal clock time</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </parameter>
        <parameter name="requested_skew" transfer-ownership="none">
          <doc xml:space="preserve">skew amount requested by the callback</doc>
          <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff*"/>
        </parameter>
        <parameter name="discont_reason" transfer-ownership="none">
          <doc xml:space="preserve">TRUE if there was a discontinuity in the average skew</doc>
          <type name="AudioBaseSinkDiscontReason"
                c:type="GstAudioBaseSinkDiscontReason"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="5">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="AudioBaseSinkDiscontReason"
                 version="1.6"
                 c:type="GstAudioBaseSinkDiscontReason">
      <doc xml:space="preserve">GST_AUDIO_BASE_SINK_DISCONT_REASON_NO_DISCONT: No discontinuity occurred
GST_AUDIO_BASE_SINK_DISCONT_REASON_NEW_CAPS: New caps are set, causing renegotiotion
GST_AUDIO_BASE_SINK_DISCONT_REASON_FLUSH: Samples have been flushed
GST_AUDIO_BASE_SINK_DISCONT_REASON_SYNC_LATENCY: Sink was synchronized to the estimated latency (occurs during initialization)
GST_AUDIO_BASE_SINK_DISCONT_REASON_ALIGNMENT: Aligning buffers failed because the timestamps are too discontinuous
GST_AUDIO_BASE_SINK_DISCONT_REASON_DEVICE_FAILURE: Audio output device experienced and recovered from an error but introduced latency in the process (see also @gst_audio_base_sink_report_device_failure)
Different possible reasons for discontinuities. This enum is useful for the custom
slave method.</doc>
      <member name="no_discont"
              value="0"
              c:identifier="GST_AUDIO_BASE_SINK_DISCONT_REASON_NO_DISCONT">
      </member>
      <member name="new_caps"
              value="1"
              c:identifier="GST_AUDIO_BASE_SINK_DISCONT_REASON_NEW_CAPS">
      </member>
      <member name="flush"
              value="2"
              c:identifier="GST_AUDIO_BASE_SINK_DISCONT_REASON_FLUSH">
      </member>
      <member name="sync_latency"
              value="3"
              c:identifier="GST_AUDIO_BASE_SINK_DISCONT_REASON_SYNC_LATENCY">
      </member>
      <member name="alignment"
              value="4"
              c:identifier="GST_AUDIO_BASE_SINK_DISCONT_REASON_ALIGNMENT">
      </member>
      <member name="device_failure"
              value="5"
              c:identifier="GST_AUDIO_BASE_SINK_DISCONT_REASON_DEVICE_FAILURE">
      </member>
    </enumeration>
    <record name="AudioBaseSinkPrivate"
            c:type="GstAudioBaseSinkPrivate"
            disguised="1">
    </record>
    <enumeration name="AudioBaseSinkSlaveMethod"
                 glib:type-name="GstAudioBaseSinkSlaveMethod"
                 glib:get-type="gst_audio_base_sink_slave_method_get_type"
                 c:type="GstAudioBaseSinkSlaveMethod">
      <doc xml:space="preserve">Different possible clock slaving algorithms used when the internal audio
clock is not selected as the pipeline master clock.</doc>
      <member name="resample"
              value="0"
              c:identifier="GST_AUDIO_BASE_SINK_SLAVE_RESAMPLE"
              glib:nick="resample">
        <doc xml:space="preserve">Resample to match the master clock</doc>
      </member>
      <member name="skew"
              value="1"
              c:identifier="GST_AUDIO_BASE_SINK_SLAVE_SKEW"
              glib:nick="skew">
        <doc xml:space="preserve">Adjust playout pointer when master clock
drifts too much.</doc>
      </member>
      <member name="none"
              value="2"
              c:identifier="GST_AUDIO_BASE_SINK_SLAVE_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No adjustment is done.</doc>
      </member>
      <member name="custom"
              value="3"
              c:identifier="GST_AUDIO_BASE_SINK_SLAVE_CUSTOM"
              glib:nick="custom">
        <doc xml:space="preserve">Use custom clock slaving algorithm (Since: 1.6)</doc>
      </member>
    </enumeration>
    <class name="AudioBaseSrc"
           c:symbol-prefix="audio_base_src"
           c:type="GstAudioBaseSrc"
           parent="GstBase.PushSrc"
           glib:type-name="GstAudioBaseSrc"
           glib:get-type="gst_audio_base_src_get_type"
           glib:type-struct="AudioBaseSrcClass">
      <doc xml:space="preserve">This is the base class for audio sources. Subclasses need to implement the
::create_ringbuffer vmethod. This base class will then take care of
reading samples from the ringbuffer, synchronisation and flushing.</doc>
      <virtual-method name="create_ringbuffer" invoker="create_ringbuffer">
        <doc xml:space="preserve">Create and return the #GstAudioRingBuffer for @src. This function will call
the ::create_ringbuffer vmethod and will set @src as the parent of the
returned buffer (see gst_object_set_parent()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The new ringbuffer of @src.</doc>
          <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSrc.</doc>
            <type name="AudioBaseSrc" c:type="GstAudioBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="create_ringbuffer"
              c:identifier="gst_audio_base_src_create_ringbuffer">
        <doc xml:space="preserve">Create and return the #GstAudioRingBuffer for @src. This function will call
the ::create_ringbuffer vmethod and will set @src as the parent of the
returned buffer (see gst_object_set_parent()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The new ringbuffer of @src.</doc>
          <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSrc.</doc>
            <type name="AudioBaseSrc" c:type="GstAudioBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_provide_clock"
              c:identifier="gst_audio_base_src_get_provide_clock">
        <doc xml:space="preserve">Queries whether @src will provide a clock or not. See also
gst_audio_base_src_set_provide_clock.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @src will provide a clock.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSrc</doc>
            <type name="AudioBaseSrc" c:type="GstAudioBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_slave_method"
              c:identifier="gst_audio_base_src_get_slave_method">
        <doc xml:space="preserve">Get the current slave method used by @src.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current slave method used by @src.</doc>
          <type name="AudioBaseSrcSlaveMethod"
                c:type="GstAudioBaseSrcSlaveMethod"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSrc</doc>
            <type name="AudioBaseSrc" c:type="GstAudioBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_provide_clock"
              c:identifier="gst_audio_base_src_set_provide_clock">
        <doc xml:space="preserve">Controls whether @src will provide a clock or not. If @provide is %TRUE,
gst_element_provide_clock() will return a clock that reflects the datarate
of @src. If @provide is %FALSE, gst_element_provide_clock() will return NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSrc</doc>
            <type name="AudioBaseSrc" c:type="GstAudioBaseSrc*"/>
          </instance-parameter>
          <parameter name="provide" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_slave_method"
              c:identifier="gst_audio_base_src_set_slave_method">
        <doc xml:space="preserve">Controls how clock slaving will be performed in @src.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSrc</doc>
            <type name="AudioBaseSrc" c:type="GstAudioBaseSrc*"/>
          </instance-parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">the new slave method</doc>
            <type name="AudioBaseSrcSlaveMethod"
                  c:type="GstAudioBaseSrcSlaveMethod"/>
          </parameter>
        </parameters>
      </method>
      <property name="actual-buffer-time" transfer-ownership="none">
        <doc xml:space="preserve">Actual configured size of audio buffer in microseconds.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="actual-latency-time" transfer-ownership="none">
        <doc xml:space="preserve">Actual configured audio latency in microseconds.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="buffer-time" writable="1" transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="latency-time" writable="1" transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="provide-clock" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="slave-method" writable="1" transfer-ownership="none">
        <type name="AudioBaseSrcSlaveMethod"/>
      </property>
      <field name="element">
        <type name="GstBase.PushSrc" c:type="GstPushSrc"/>
      </field>
      <field name="ringbuffer">
        <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
      </field>
      <field name="buffer_time">
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="latency_time">
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="next_sample">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="clock">
        <type name="Gst.Clock" c:type="GstClock*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AudioBaseSrcPrivate" c:type="GstAudioBaseSrcPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioBaseSrcClass"
            c:type="GstAudioBaseSrcClass"
            glib:is-gtype-struct-for="AudioBaseSrc">
      <doc xml:space="preserve">#GstAudioBaseSrc class. Override the vmethod to implement
functionality.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class.</doc>
        <type name="GstBase.PushSrcClass" c:type="GstPushSrcClass"/>
      </field>
      <field name="create_ringbuffer">
        <callback name="create_ringbuffer">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The new ringbuffer of @src.</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <doc xml:space="preserve">a #GstAudioBaseSrc.</doc>
              <type name="AudioBaseSrc" c:type="GstAudioBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AudioBaseSrcPrivate"
            c:type="GstAudioBaseSrcPrivate"
            disguised="1">
    </record>
    <enumeration name="AudioBaseSrcSlaveMethod"
                 glib:type-name="GstAudioBaseSrcSlaveMethod"
                 glib:get-type="gst_audio_base_src_slave_method_get_type"
                 c:type="GstAudioBaseSrcSlaveMethod">
      <doc xml:space="preserve">Different possible clock slaving algorithms when the internal audio clock was
not selected as the pipeline clock.</doc>
      <member name="resample"
              value="0"
              c:identifier="GST_AUDIO_BASE_SRC_SLAVE_RESAMPLE"
              glib:nick="resample">
        <doc xml:space="preserve">Resample to match the master clock.</doc>
      </member>
      <member name="re_timestamp"
              value="1"
              c:identifier="GST_AUDIO_BASE_SRC_SLAVE_RETIMESTAMP"
              glib:nick="re-timestamp">
        <doc xml:space="preserve">Retimestamp output buffers with master
clock time.</doc>
      </member>
      <member name="skew"
              value="2"
              c:identifier="GST_AUDIO_BASE_SRC_SLAVE_SKEW"
              glib:nick="skew">
        <doc xml:space="preserve">Adjust capture pointer when master clock
drifts too much.</doc>
      </member>
      <member name="none"
              value="3"
              c:identifier="GST_AUDIO_BASE_SRC_SLAVE_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No adjustment is done.</doc>
      </member>
    </enumeration>
    <class name="AudioCdSrc"
           c:symbol-prefix="audio_cd_src"
           c:type="GstAudioCdSrc"
           parent="GstBase.PushSrc"
           glib:type-name="GstAudioCdSrc"
           glib:get-type="gst_audio_cd_src_get_type"
           glib:type-struct="AudioCdSrcClass">
      <doc xml:space="preserve">&lt;para&gt;
Provides a base class for CD digital audio (CDDA) sources, which handles
things like seeking, querying, discid calculation, tags, and buffer
timestamping.
&lt;/para&gt;
&lt;refsect2&gt;
&lt;title&gt;Using GstAudioCdSrc-based elements in applications&lt;/title&gt;
&lt;para&gt;
GstAudioCdSrc registers two #GstFormat&lt;!-- --&gt;s of its own, namely
the "track" format and the "sector" format. Applications will usually
only find the "track" format interesting. You can retrieve that #GstFormat
for use in seek events or queries with gst_format_get_by_nick("track").
&lt;/para&gt;
&lt;para&gt;
In order to query the number of tracks, for example, an application would
set the CDDA source element to READY or PAUSED state and then query the
the number of tracks via gst_element_query_duration() using the track
format acquired above. Applications can query the currently playing track
in the same way.
&lt;/para&gt;
&lt;para&gt;
Alternatively, applications may retrieve the currently playing track and
the total number of tracks from the taglist that will posted on the bus
whenever the CD is opened or the currently playing track changes. The
taglist will contain GST_TAG_TRACK_NUMBER and GST_TAG_TRACK_COUNT tags.
&lt;/para&gt;
&lt;para&gt;
Applications playing back CD audio using playbin and cdda://n URIs should
issue a seek command in track format to change between tracks, rather than
setting a new cdda://n+1 URI on playbin (as setting a new URI on playbin
involves closing and re-opening the CD device, which is much much slower).
&lt;/para&gt;
&lt;refsect2&gt;
&lt;/refsect2&gt;
&lt;title&gt;Tags and meta-information&lt;/title&gt;
&lt;para&gt;
CDDA sources will automatically emit a number of tags, details about which
can be found in the libgsttag documentation. Those tags are:
#GST_TAG_CDDA_CDDB_DISCID, #GST_TAG_CDDA_CDDB_DISCID_FULL,
#GST_TAG_CDDA_MUSICBRAINZ_DISCID, #GST_TAG_CDDA_MUSICBRAINZ_DISCID_FULL,
among others.
&lt;/para&gt;
&lt;/refsect2&gt;
&lt;refsect2&gt;
&lt;title&gt;Tracks and Table of Contents (TOC)&lt;/title&gt;
&lt;para&gt;
Applications will be informed of the available tracks via a TOC message
on the pipeline's #GstBus. The #GstToc will contain a #GstTocEntry for
each track, with information about each track. The duration for each
track can be retrieved via the #GST_TAG_DURATION tag from each entry's
tag list, or calculated via gst_toc_entry_get_start_stop_times().
The track entries in the TOC will be sorted by track number.
&lt;/para&gt;
&lt;/refsect2&gt;</doc>
      <implements name="Gst.URIHandler"/>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioCdSrc" c:type="GstAudioCdSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioCdSrc" c:type="GstAudioCdSrc*"/>
          </instance-parameter>
          <parameter name="device" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_sector">
        <return-value transfer-ownership="full">
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioCdSrc" c:type="GstAudioCdSrc*"/>
          </instance-parameter>
          <parameter name="sector" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_track" c:identifier="gst_audio_cd_src_add_track">
        <doc xml:space="preserve">CDDA sources use this function from their start vfunc to announce the
available data and audio tracks to the base source class. The caller
should allocate @track on the stack, the base source will do a shallow
copy of the structure (and take ownership of the taglist if there is one).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">FALSE on error, otherwise TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioCdSrc</doc>
            <type name="AudioCdSrc" c:type="GstAudioCdSrc*"/>
          </instance-parameter>
          <parameter name="track" transfer-ownership="none">
            <doc xml:space="preserve">address of #GstAudioCdSrcTrack to add</doc>
            <type name="AudioCdSrcTrack" c:type="GstAudioCdSrcTrack*"/>
          </parameter>
        </parameters>
      </method>
      <property name="device" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mode" writable="1" transfer-ownership="none">
        <type name="AudioCdSrcMode"/>
      </property>
      <property name="track" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="pushsrc">
        <type name="GstBase.PushSrc" c:type="GstPushSrc"/>
      </field>
      <field name="tags">
        <type name="Gst.TagList" c:type="GstTagList*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AudioCdSrcPrivate" c:type="GstAudioCdSrcPrivate*"/>
      </field>
      <field name="_gst_reserved1" readable="0" private="1">
        <array zero-terminated="0" c:type="guint" fixed-size="2">
          <type name="guint" c:type="guint"/>
        </array>
      </field>
      <field name="_gst_reserved2" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioCdSrcClass"
            c:type="GstAudioCdSrcClass"
            glib:is-gtype-struct-for="AudioCdSrc">
      <doc xml:space="preserve">Audio CD source base class.</doc>
      <field name="pushsrc_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="GstBase.PushSrcClass" c:type="GstPushSrcClass"/>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioCdSrc" c:type="GstAudioCdSrc*"/>
            </parameter>
            <parameter name="device" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioCdSrc" c:type="GstAudioCdSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read_sector">
        <callback name="read_sector">
          <return-value transfer-ownership="full">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioCdSrc" c:type="GstAudioCdSrc*"/>
            </parameter>
            <parameter name="sector" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="AudioCdSrcMode"
                 glib:type-name="GstAudioCdSrcMode"
                 glib:get-type="gst_audio_cd_src_mode_get_type"
                 c:type="GstAudioCdSrcMode">
      <doc xml:space="preserve">Mode in which the CD audio source operates. Influences timestamping,
EOS handling and seeking.</doc>
      <member name="normal"
              value="0"
              c:identifier="Stream consists of a single track"
              glib:nick="normal">
      </member>
      <member name="continuous"
              value="1"
              c:identifier="Stream consists of the whole disc"
              glib:nick="continuous">
      </member>
    </enumeration>
    <record name="AudioCdSrcPrivate"
            c:type="GstAudioCdSrcPrivate"
            disguised="1">
    </record>
    <record name="AudioCdSrcTrack" c:type="GstAudioCdSrcTrack">
      <doc xml:space="preserve">CD track abstraction to communicate TOC entries to the base class.

This structure is only for use by sub-classed in connection with
gst_audio_cd_src_add_track().

Applications will be informed of the available tracks via a TOC message
on the pipeline's #GstBus instead.</doc>
      <field name="is_audio" writable="1">
        <doc xml:space="preserve">Whether this is an audio track</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="num" writable="1">
        <doc xml:space="preserve">Track number in TOC (usually starts from 1, but not always)</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="start" writable="1">
        <doc xml:space="preserve">The first sector of this track (LBA)</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="end" writable="1">
        <doc xml:space="preserve">The last sector of this track (LBA)</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="tags" writable="1">
        <doc xml:space="preserve">Track-specific tags (e.g. from cd-text information), or NULL</doc>
        <type name="Gst.TagList" c:type="GstTagList*"/>
      </field>
      <field name="_gst_reserved1" readable="0" private="1">
        <array zero-terminated="0" c:type="guint" fixed-size="2">
          <type name="guint" c:type="guint"/>
        </array>
      </field>
      <field name="_gst_reserved2" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="AudioChannelPosition"
                 glib:type-name="GstAudioChannelPosition"
                 glib:get-type="gst_audio_channel_position_get_type"
                 c:type="GstAudioChannelPosition">
      <doc xml:space="preserve">Audio channel positions.

These are the channels defined in SMPTE 2036-2-2008
Table 1 for 22.2 audio systems with the Surround and Wide channels from
DTS Coherent Acoustics (v.1.3.1) and 10.2 and 7.1 layouts. In the caps the
actual channel layout is expressed with a channel count and a channel mask,
which describes the existing channels. The positions in the bit mask correspond
to the enum values.
For negotiation it is allowed to have more bits set in the channel mask than
the number of channels to specify the allowed channel positions but this is
not allowed in negotiated caps. It is not allowed in any situation other
than the one mentioned below to have less bits set in the channel mask than
the number of channels.

@GST_AUDIO_CHANNEL_POSITION_MONO can only be used with a single mono channel that
has no direction information and would be mixed into all directional channels.
This is expressed in caps by having a single channel and no channel mask.

@GST_AUDIO_CHANNEL_POSITION_NONE can only be used if all channels have this position.
This is expressed in caps by having a channel mask with no bits set.

As another special case it is allowed to have two channels without a channel mask.
This implicitely means that this is a stereo stream with a front left and front right
channel.</doc>
      <member name="none"
              value="-3"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_NONE"
              glib:nick="none">
        <doc xml:space="preserve">used for position-less channels, e.g.
    from a sound card that records 1024 channels; mutually exclusive with
    any other channel position</doc>
      </member>
      <member name="mono"
              value="-2"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_MONO"
              glib:nick="mono">
        <doc xml:space="preserve">Mono without direction;
    can only be used with 1 channel</doc>
      </member>
      <member name="invalid"
              value="-1"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_INVALID"
              glib:nick="invalid">
        <doc xml:space="preserve">invalid position</doc>
      </member>
      <member name="front_left"
              value="0"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT"
              glib:nick="front-left">
        <doc xml:space="preserve">Front left</doc>
      </member>
      <member name="front_right"
              value="1"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT"
              glib:nick="front-right">
        <doc xml:space="preserve">Front right</doc>
      </member>
      <member name="front_center"
              value="2"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER"
              glib:nick="front-center">
        <doc xml:space="preserve">Front center</doc>
      </member>
      <member name="lfe1"
              value="3"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_LFE1"
              glib:nick="lfe1">
        <doc xml:space="preserve">Low-frequency effects 1 (subwoofer)</doc>
      </member>
      <member name="rear_left"
              value="4"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_REAR_LEFT"
              glib:nick="rear-left">
        <doc xml:space="preserve">Rear left</doc>
      </member>
      <member name="rear_right"
              value="5"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT"
              glib:nick="rear-right">
        <doc xml:space="preserve">Rear right</doc>
      </member>
      <member name="front_left_of_center"
              value="6"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER"
              glib:nick="front-left-of-center">
        <doc xml:space="preserve">Front left of center</doc>
      </member>
      <member name="front_right_of_center"
              value="7"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER"
              glib:nick="front-right-of-center">
        <doc xml:space="preserve">Front right of center</doc>
      </member>
      <member name="rear_center"
              value="8"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_REAR_CENTER"
              glib:nick="rear-center">
        <doc xml:space="preserve">Rear center</doc>
      </member>
      <member name="lfe2"
              value="9"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_LFE2"
              glib:nick="lfe2">
        <doc xml:space="preserve">Low-frequency effects 2 (subwoofer)</doc>
      </member>
      <member name="side_left"
              value="10"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT"
              glib:nick="side-left">
        <doc xml:space="preserve">Side left</doc>
      </member>
      <member name="side_right"
              value="11"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT"
              glib:nick="side-right">
        <doc xml:space="preserve">Side right</doc>
      </member>
      <member name="top_front_left"
              value="12"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT"
              glib:nick="top-front-left">
        <doc xml:space="preserve">Top front left</doc>
      </member>
      <member name="top_front_right"
              value="13"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT"
              glib:nick="top-front-right">
        <doc xml:space="preserve">Top front right</doc>
      </member>
      <member name="top_front_center"
              value="14"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER"
              glib:nick="top-front-center">
        <doc xml:space="preserve">Top front center</doc>
      </member>
      <member name="top_center"
              value="15"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_CENTER"
              glib:nick="top-center">
        <doc xml:space="preserve">Top center</doc>
      </member>
      <member name="top_rear_left"
              value="16"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT"
              glib:nick="top-rear-left">
        <doc xml:space="preserve">Top rear left</doc>
      </member>
      <member name="top_rear_right"
              value="17"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT"
              glib:nick="top-rear-right">
        <doc xml:space="preserve">Top rear right</doc>
      </member>
      <member name="top_side_left"
              value="18"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_LEFT"
              glib:nick="top-side-left">
        <doc xml:space="preserve">Top side right</doc>
      </member>
      <member name="top_side_right"
              value="19"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_RIGHT"
              glib:nick="top-side-right">
        <doc xml:space="preserve">Top rear right</doc>
      </member>
      <member name="top_rear_center"
              value="20"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER"
              glib:nick="top-rear-center">
        <doc xml:space="preserve">Top rear center</doc>
      </member>
      <member name="bottom_front_center"
              value="21"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_CENTER"
              glib:nick="bottom-front-center">
        <doc xml:space="preserve">Bottom front center</doc>
      </member>
      <member name="bottom_front_left"
              value="22"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_LEFT"
              glib:nick="bottom-front-left">
        <doc xml:space="preserve">Bottom front left</doc>
      </member>
      <member name="bottom_front_right"
              value="23"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_RIGHT"
              glib:nick="bottom-front-right">
        <doc xml:space="preserve">Bottom front right</doc>
      </member>
      <member name="wide_left"
              value="24"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_WIDE_LEFT"
              glib:nick="wide-left">
        <doc xml:space="preserve">Wide left (between front left and side left)</doc>
      </member>
      <member name="wide_right"
              value="25"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_WIDE_RIGHT"
              glib:nick="wide-right">
        <doc xml:space="preserve">Wide right (between front right and side right)</doc>
      </member>
      <member name="surround_left"
              value="26"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT"
              glib:nick="surround-left">
        <doc xml:space="preserve">Surround left (between rear left and side left)</doc>
      </member>
      <member name="surround_right"
              value="27"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT"
              glib:nick="surround-right">
        <doc xml:space="preserve">Surround right (between rear right and side right)</doc>
      </member>
    </enumeration>
    <class name="AudioClock"
           c:symbol-prefix="audio_clock"
           c:type="GstAudioClock"
           parent="Gst.SystemClock"
           glib:type-name="GstAudioClock"
           glib:get-type="gst_audio_clock_get_type"
           glib:type-struct="AudioClockClass">
      <doc xml:space="preserve">#GstAudioClock makes it easy for elements to implement a #GstClock, they
simply need to provide a function that returns the current clock time.

This object is internally used to implement the clock in #GstAudioBaseSink.</doc>
      <constructor name="new" c:identifier="gst_audio_clock_new">
        <doc xml:space="preserve">Create a new #GstAudioClock instance. Whenever the clock time should be
calculated it will call @func with @user_data. When @func returns
#GST_CLOCK_TIME_NONE, the clock will return the last reported time.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new #GstAudioClock casted to a #GstClock.</doc>
          <type name="Gst.Clock" c:type="GstClock*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the clock</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:space="preserve">a function</doc>
            <type name="AudioClockGetTimeFunc"
                  c:type="GstAudioClockGetTimeFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_notify"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:space="preserve">#GDestroyNotify for @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="adjust" c:identifier="gst_audio_clock_adjust">
        <doc xml:space="preserve">Adjust @time with the internal offset of the audio clock.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@time adjusted with the internal offset.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioClock</doc>
            <type name="Gst.Clock" c:type="GstClock*"/>
          </parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:space="preserve">a #GstClockTime</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_time" c:identifier="gst_audio_clock_get_time">
        <doc xml:space="preserve">Report the time as returned by the #GstAudioClockGetTimeFunc without applying
any offsets.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the time as reported by the time function of the audio clock</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioClock</doc>
            <type name="Gst.Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </function>
      <function name="invalidate" c:identifier="gst_audio_clock_invalidate">
        <doc xml:space="preserve">Invalidate the clock function. Call this function when the provided
#GstAudioClockGetTimeFunc cannot be called anymore, for example, when the
user_data becomes invalid.

After calling this function, @clock will return the last returned time for
the rest of its lifetime.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioClock</doc>
            <type name="Gst.Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </function>
      <method name="reset" c:identifier="gst_audio_clock_reset">
        <doc xml:space="preserve">Inform @clock that future calls to #GstAudioClockGetTimeFunc will return values
starting from @time. The clock will update an internal offset to make sure that
future calls to internal_time will return an increasing result as required by
the #GstClock object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="clock" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioClock</doc>
            <type name="AudioClock" c:type="GstAudioClock*"/>
          </instance-parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:space="preserve">a #GstClockTime</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <field name="clock">
        <type name="Gst.SystemClock" c:type="GstSystemClock"/>
      </field>
      <field name="func">
        <type name="AudioClockGetTimeFunc" c:type="GstAudioClockGetTimeFunc"/>
      </field>
      <field name="user_data">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="destroy_notify">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="last_time" readable="0" private="1">
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="time_offset" readable="0" private="1">
        <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioClockClass"
            c:type="GstAudioClockClass"
            glib:is-gtype-struct-for="AudioClock">
      <field name="parent_class">
        <type name="Gst.SystemClockClass" c:type="GstSystemClockClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="AudioClockGetTimeFunc" c:type="GstAudioClockGetTimeFunc">
      <doc xml:space="preserve">This function will be called whenever the current clock time needs to be
calculated. If this function returns #GST_CLOCK_TIME_NONE, the last reported
time will be returned by the clock.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the current time or #GST_CLOCK_TIME_NONE if the previous time should
be used.</doc>
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </return-value>
      <parameters>
        <parameter name="clock" transfer-ownership="none">
          <doc xml:space="preserve">the #GstAudioClock</doc>
          <type name="Gst.Clock" c:type="GstClock*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="AudioDecoder"
           c:symbol-prefix="audio_decoder"
           c:type="GstAudioDecoder"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstAudioDecoder"
           glib:get-type="gst_audio_decoder_get_type"
           glib:type-struct="AudioDecoderClass">
      <doc xml:space="preserve">This base class is for audio decoders turning encoded data into
raw audio samples.

GstAudioDecoder and subclass should cooperate as follows.
&lt;orderedlist&gt;
&lt;listitem&gt;
  &lt;itemizedlist&gt;&lt;title&gt;Configuration&lt;/title&gt;
  &lt;listitem&gt;&lt;para&gt;
    Initially, GstAudioDecoder calls @start when the decoder element
    is activated, which allows subclass to perform any global setup.
    Base class (context) parameters can already be set according to subclass
    capabilities (or possibly upon receive more information in subsequent
    @set_format).
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
    GstAudioDecoder calls @set_format to inform subclass of the format
    of input audio data that it is about to receive.
    While unlikely, it might be called more than once, if changing input
    parameters require reconfiguration.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
    GstAudioDecoder calls @stop at end of all processing.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;/itemizedlist&gt;
&lt;/listitem&gt;
As of configuration stage, and throughout processing, GstAudioDecoder
provides various (context) parameters, e.g. describing the format of
output audio data (valid when output caps have been set) or current parsing state.
Conversely, subclass can and should configure context to inform
base class of its expectation w.r.t. buffer handling.
&lt;listitem&gt;
  &lt;itemizedlist&gt;
  &lt;title&gt;Data processing&lt;/title&gt;
    &lt;listitem&gt;&lt;para&gt;
      Base class gathers input data, and optionally allows subclass
      to parse this into subsequently manageable (as defined by subclass)
      chunks.  Such chunks are subsequently referred to as 'frames',
      though they may or may not correspond to 1 (or more) audio format frame.
    &lt;/para&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;para&gt;
      Input frame is provided to subclass' @handle_frame.
    &lt;/para&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;para&gt;
      If codec processing results in decoded data, subclass should call
      @gst_audio_decoder_finish_frame to have decoded data pushed
      downstream.
    &lt;/para&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;para&gt;
      Just prior to actually pushing a buffer downstream,
      it is passed to @pre_push.  Subclass should either use this callback
      to arrange for additional downstream pushing or otherwise ensure such
      custom pushing occurs after at least a method call has finished since
      setting src pad caps.
    &lt;/para&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;para&gt;
      During the parsing process GstAudioDecoderClass will handle both
      srcpad and sinkpad events. Sink events will be passed to subclass
      if @event callback has been provided.
    &lt;/para&gt;&lt;/listitem&gt;
  &lt;/itemizedlist&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
  &lt;itemizedlist&gt;&lt;title&gt;Shutdown phase&lt;/title&gt;
  &lt;listitem&gt;&lt;para&gt;
    GstAudioDecoder class calls @stop to inform the subclass that data
    parsing will be stopped.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;/itemizedlist&gt;
&lt;/listitem&gt;
&lt;/orderedlist&gt;

Subclass is responsible for providing pad template caps for
source and sink pads. The pads need to be named "sink" and "src". It also
needs to set the fixed caps on srcpad, when the format is ensured.  This
is typically when base class calls subclass' @set_format function, though
it might be delayed until calling @gst_audio_decoder_finish_frame.

In summary, above process should have subclass concentrating on
codec data processing while leaving other matters to base class,
such as most notably timestamp handling.  While it may exert more control
in this area (see e.g. @pre_push), it is very much not recommended.

In particular, base class will try to arrange for perfect output timestamps
as much as possible while tracking upstream timestamps.
To this end, if deviation between the next ideal expected perfect timestamp
and upstream exceeds #GstAudioDecoder:tolerance, then resync to upstream
occurs (which would happen always if the tolerance mechanism is disabled).

In non-live pipelines, baseclass can also (configurably) arrange for
output buffer aggregation which may help to redue large(r) numbers of
small(er) buffers being pushed and processed downstream.

On the other hand, it should be noted that baseclass only provides limited
seeking support (upon explicit subclass request), as full-fledged support
should rather be left to upstream demuxer, parser or alike.  This simple
approach caters for seeking and duration reporting using estimated input
bitrates.

Things that subclass need to take care of:
&lt;itemizedlist&gt;
  &lt;listitem&gt;&lt;para&gt;Provide pad templates&lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
     Set source pad caps when appropriate
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
     Set user-configurable properties to sane defaults for format and
     implementing codec at hand, and convey some subclass capabilities and
     expectations in context.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
     Accept data in @handle_frame and provide encoded results to
     @gst_audio_decoder_finish_frame.  If it is prepared to perform
     PLC, it should also accept NULL data in @handle_frame and provide for
     data for indicated duration.
  &lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="decide_allocation">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="flush">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="hard" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="getcaps">
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_frame">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="negotiate" invoker="negotiate">
        <doc xml:space="preserve">Negotiate with downstream elements to currently configured #GstAudioInfo.
Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if
negotiate fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#TRUE if the negotiation succeeded, else #FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="parse">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="adapter" transfer-ownership="none">
            <type name="GstBase.Adapter" c:type="GstAdapter*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="pre_push">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="propose_allocation">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_format">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sink_event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sink_query">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="src_event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="src_query">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="allocate_output_buffer"
              c:identifier="gst_audio_decoder_allocate_output_buffer">
        <doc xml:space="preserve">Helper function that allocates a buffer to hold an audio frame
for @dec's current output format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">allocated buffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">size of the buffer</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="finish_frame"
              c:identifier="gst_audio_decoder_finish_frame">
        <doc xml:space="preserve">Collects decoded data and pushes it downstream.

@buf may be NULL in which case the indicated number of frames
are discarded and considered to have produced no output
(e.g. lead-in or setup frames).
Otherwise, source pad caps must be set when it is called with valid
data in @buf.

Note that a frame received in gst_audio_decoder_handle_frame() may be
invalidated by a call to this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GstFlowReturn that should be escalated to caller (of caller)</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">decoded data</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="frames" transfer-ownership="none">
            <doc xml:space="preserve">number of decoded frames represented by decoded data</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_allocator"
              c:identifier="gst_audio_decoder_get_allocator">
        <doc xml:space="preserve">Lets #GstAudioDecoder sub-classes to know the memory @allocator
used by the base class and its @params.

Unref the @allocator after use it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="allocator"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">the #GstAllocator
used</doc>
            <type name="Gst.Allocator" c:type="GstAllocator**"/>
          </parameter>
          <parameter name="params"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">the
#GstAllocatorParams of @allocator</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_audio_info"
              c:identifier="gst_audio_decoder_get_audio_info">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GstAudioInfo describing the input audio format</doc>
          <type name="AudioInfo" c:type="GstAudioInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_delay" c:identifier="gst_audio_decoder_get_delay">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">currently configured decoder delay</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_drainable"
              c:identifier="gst_audio_decoder_get_drainable">
        <doc xml:space="preserve">Queries decoder drain handling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if drainable handling is enabled.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_estimate_rate"
              c:identifier="gst_audio_decoder_get_estimate_rate">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">currently configured byte to time conversion setting</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_latency" c:identifier="gst_audio_decoder_get_latency">
        <doc xml:space="preserve">Sets the variables pointed to by @min and @max to the currently configured
latency.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="min"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">a pointer to storage to hold minimum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="max"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">a pointer to storage to hold maximum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_max_errors"
              c:identifier="gst_audio_decoder_get_max_errors">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">currently configured decoder tolerated error count.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_min_latency"
              c:identifier="gst_audio_decoder_get_min_latency">
        <doc xml:space="preserve">Queries decoder's latency aggregation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">aggregation latency.

MT safe.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_needs_format"
              c:identifier="gst_audio_decoder_get_needs_format">
        <doc xml:space="preserve">Queries decoder required format handling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if required format handling is enabled.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parse_state"
              c:identifier="gst_audio_decoder_get_parse_state">
        <doc xml:space="preserve">Return current parsing (sync and eos) state.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="sync" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a variable to hold the current sync state</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="eos" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a variable to hold the current eos state</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_plc" c:identifier="gst_audio_decoder_get_plc">
        <doc xml:space="preserve">Queries decoder packet loss concealment handling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if packet loss concealment is enabled.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_plc_aware"
              c:identifier="gst_audio_decoder_get_plc_aware">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">currently configured plc handling</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tolerance"
              c:identifier="gst_audio_decoder_get_tolerance">
        <doc xml:space="preserve">Queries current audio jitter tolerance threshold.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">decoder audio jitter tolerance threshold.

MT safe.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="merge_tags" c:identifier="gst_audio_decoder_merge_tags">
        <doc xml:space="preserve">Adds tags to so-called pending tags, which will be processed
before pushing out data downstream.

Note that this is provided for convenience, and the subclass is
not required to use this and can still do tag handling on its own,
although it should be aware that baseclass already takes care
of the usual CODEC/AUDIO_CODEC tags.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="tags" transfer-ownership="none">
            <doc xml:space="preserve">a #GstTagList to merge</doc>
            <type name="Gst.TagList" c:type="const GstTagList*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">the #GstTagMergeMode to use</doc>
            <type name="Gst.TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="negotiate" c:identifier="gst_audio_decoder_negotiate">
        <doc xml:space="preserve">Negotiate with downstream elements to currently configured #GstAudioInfo.
Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if
negotiate fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#TRUE if the negotiation succeeded, else #FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="proxy_getcaps"
              c:identifier="gst_audio_decoder_proxy_getcaps"
              version="1.6">
        <doc xml:space="preserve">Returns caps that express @caps (or sink template caps if @caps == NULL)
restricted to rate/channels/... combinations supported by downstream
elements.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GstCaps owned by caller</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="decoder" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="caps"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">initial caps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="filter"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">filter caps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_drainable"
              c:identifier="gst_audio_decoder_set_drainable">
        <doc xml:space="preserve">Configures decoder drain handling.  If drainable, subclass might
be handed a NULL buffer to have it return any leftover decoded data.
Otherwise, it is not considered so capable and will only ever be passed
real data.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_estimate_rate"
              c:identifier="gst_audio_decoder_set_estimate_rate">
        <doc xml:space="preserve">Allows baseclass to perform byte to time estimated conversion.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">whether to enable byte to time conversion</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_latency" c:identifier="gst_audio_decoder_set_latency">
        <doc xml:space="preserve">Sets decoder latency.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="min" transfer-ownership="none">
            <doc xml:space="preserve">minimum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="max" transfer-ownership="none">
            <doc xml:space="preserve">maximum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_errors"
              c:identifier="gst_audio_decoder_set_max_errors">
        <doc xml:space="preserve">Sets numbers of tolerated decoder errors, where a tolerated one is then only
warned about, but more than tolerated will lead to fatal error. You can set
-1 for never returning fatal errors. Default is set to
GST_AUDIO_DECODER_MAX_ERRORS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="num" transfer-ownership="none">
            <doc xml:space="preserve">max tolerated errors</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_min_latency"
              c:identifier="gst_audio_decoder_set_min_latency">
        <doc xml:space="preserve">Sets decoder minimum aggregation latency.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="num" transfer-ownership="none">
            <doc xml:space="preserve">new minimum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_needs_format"
              c:identifier="gst_audio_decoder_set_needs_format">
        <doc xml:space="preserve">Configures decoder format needs.  If enabled, subclass needs to be
negotiated with format caps before it can process any data.  It will then
never be handed any data before it has been configured.
Otherwise, it might be handed data without having been configured and
is then expected being able to do so either by default
or based on the input data.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_output_format"
              c:identifier="gst_audio_decoder_set_output_format">
        <doc xml:space="preserve">Configure output info on the srcpad of @dec.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">#GstAudioInfo</doc>
            <type name="AudioInfo" c:type="const GstAudioInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_plc" c:identifier="gst_audio_decoder_set_plc">
        <doc xml:space="preserve">Enable or disable decoder packet loss concealment, provided subclass
and codec are capable and allow handling plc.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_plc_aware"
              c:identifier="gst_audio_decoder_set_plc_aware">
        <doc xml:space="preserve">Indicates whether or not subclass handles packet loss concealment (plc).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="plc" transfer-ownership="none">
            <doc xml:space="preserve">new plc state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tolerance"
              c:identifier="gst_audio_decoder_set_tolerance">
        <doc xml:space="preserve">Configures decoder audio jitter tolerance threshold.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="tolerance" transfer-ownership="none">
            <doc xml:space="preserve">new tolerance</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <property name="min-latency" writable="1" transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="plc" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="tolerance" writable="1" transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <field name="element">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="sinkpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="srcpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="stream_lock">
        <type name="GLib.RecMutex" c:type="GRecMutex"/>
      </field>
      <field name="input_segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="output_segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AudioDecoderPrivate" c:type="GstAudioDecoderPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioDecoderClass"
            c:type="GstAudioDecoderClass"
            glib:is-gtype-struct-for="AudioDecoder">
      <doc xml:space="preserve">Subclasses can override any of the available virtual methods or not, as
needed. At minimum @handle_frame (and likely @set_format) needs to be
overridden.</doc>
      <field name="element_class">
        <doc xml:space="preserve">The parent class structure</doc>
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_format">
        <callback name="set_format">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="parse">
        <callback name="parse">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="adapter" transfer-ownership="none">
              <type name="GstBase.Adapter" c:type="GstAdapter*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="gint" c:type="gint*"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="gint" c:type="gint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handle_frame">
        <callback name="handle_frame">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flush">
        <callback name="flush">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="hard" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pre_push">
        <callback name="pre_push">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sink_event">
        <callback name="sink_event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="src_event">
        <callback name="src_event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="negotiate">
        <callback name="negotiate">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">#TRUE if the negotiation succeeded, else #FALSE.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <doc xml:space="preserve">a #GstAudioDecoder</doc>
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="decide_allocation">
        <callback name="decide_allocation">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="propose_allocation">
        <callback name="propose_allocation">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sink_query">
        <callback name="sink_query">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="src_query">
        <callback name="src_query">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="getcaps">
        <callback name="getcaps">
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="filter" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="17">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AudioDecoderPrivate"
            c:type="GstAudioDecoderPrivate"
            disguised="1">
    </record>
    <record name="AudioDownmixMeta" c:type="GstAudioDownmixMeta">
      <doc xml:space="preserve">Extra buffer metadata describing audio downmixing matrix. This metadata is
attached to audio buffers and contains a matrix to downmix the buffer number
of channels to @channels.

@matrix is an two-dimensional array of @to_channels times @from_channels
coefficients, i.e. the i-th output channels is constructed by multiplicating
the input channels with the coefficients in @matrix[i] and taking the sum
of the results.</doc>
      <field name="meta" writable="1">
        <doc xml:space="preserve">parent #GstMeta</doc>
        <type name="Gst.Meta" c:type="GstMeta"/>
      </field>
      <field name="from_position" writable="1">
        <doc xml:space="preserve">the channel positions of the source</doc>
        <type name="AudioChannelPosition" c:type="GstAudioChannelPosition*"/>
      </field>
      <field name="to_position" writable="1">
        <doc xml:space="preserve">the channel positions of the destination</doc>
        <type name="AudioChannelPosition" c:type="GstAudioChannelPosition*"/>
      </field>
      <field name="from_channels" writable="1">
        <doc xml:space="preserve">the number of channels of the source</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="to_channels" writable="1">
        <doc xml:space="preserve">the number of channels of the destination</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="matrix" writable="1">
        <doc xml:space="preserve">the matrix coefficients.</doc>
        <type name="gfloat" c:type="gfloat**"/>
      </field>
      <function name="get_info" c:identifier="gst_audio_downmix_meta_get_info">
        <return-value transfer-ownership="none">
          <type name="Gst.MetaInfo" c:type="const GstMetaInfo*"/>
        </return-value>
      </function>
    </record>
    <class name="AudioEncoder"
           c:symbol-prefix="audio_encoder"
           c:type="GstAudioEncoder"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstAudioEncoder"
           glib:get-type="gst_audio_encoder_get_type"
           glib:type-struct="AudioEncoderClass">
      <doc xml:space="preserve">This base class is for audio encoders turning raw audio samples into
encoded audio data.

GstAudioEncoder and subclass should cooperate as follows.
&lt;orderedlist&gt;
&lt;listitem&gt;
  &lt;itemizedlist&gt;&lt;title&gt;Configuration&lt;/title&gt;
  &lt;listitem&gt;&lt;para&gt;
    Initially, GstAudioEncoder calls @start when the encoder element
    is activated, which allows subclass to perform any global setup.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
    GstAudioEncoder calls @set_format to inform subclass of the format
    of input audio data that it is about to receive.  Subclass should
    setup for encoding and configure various base class parameters
    appropriately, notably those directing desired input data handling.
    While unlikely, it might be called more than once, if changing input
    parameters require reconfiguration.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
    GstAudioEncoder calls @stop at end of all processing.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;/itemizedlist&gt;
&lt;/listitem&gt;
As of configuration stage, and throughout processing, GstAudioEncoder
maintains various parameters that provide required context,
e.g. describing the format of input audio data.
Conversely, subclass can and should configure these context parameters
to inform base class of its expectation w.r.t. buffer handling.
&lt;listitem&gt;
  &lt;itemizedlist&gt;
  &lt;title&gt;Data processing&lt;/title&gt;
    &lt;listitem&gt;&lt;para&gt;
      Base class gathers input sample data (as directed by the context's
      frame_samples and frame_max) and provides this to subclass' @handle_frame.
    &lt;/para&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;para&gt;
      If codec processing results in encoded data, subclass should call
      gst_audio_encoder_finish_frame() to have encoded data pushed
      downstream. Alternatively, it might also call
      gst_audio_encoder_finish_frame() (with a NULL buffer and some number of
      dropped samples) to indicate dropped (non-encoded) samples.
    &lt;/para&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;para&gt;
      Just prior to actually pushing a buffer downstream,
      it is passed to @pre_push.
    &lt;/para&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;para&gt;
      During the parsing process GstAudioEncoderClass will handle both
      srcpad and sinkpad events. Sink events will be passed to subclass
      if @event callback has been provided.
    &lt;/para&gt;&lt;/listitem&gt;
  &lt;/itemizedlist&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
  &lt;itemizedlist&gt;&lt;title&gt;Shutdown phase&lt;/title&gt;
  &lt;listitem&gt;&lt;para&gt;
    GstAudioEncoder class calls @stop to inform the subclass that data
    parsing will be stopped.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;/itemizedlist&gt;
&lt;/listitem&gt;
&lt;/orderedlist&gt;

Subclass is responsible for providing pad template caps for
source and sink pads. The pads need to be named "sink" and "src". It also
needs to set the fixed caps on srcpad, when the format is ensured.  This
is typically when base class calls subclass' @set_format function, though
it might be delayed until calling @gst_audio_encoder_finish_frame.

In summary, above process should have subclass concentrating on
codec data processing while leaving other matters to base class,
such as most notably timestamp handling.  While it may exert more control
in this area (see e.g. @pre_push), it is very much not recommended.

In particular, base class will either favor tracking upstream timestamps
(at the possible expense of jitter) or aim to arrange for a perfect stream of
output timestamps, depending on #GstAudioEncoder:perfect-timestamp.
However, in the latter case, the input may not be so perfect or ideal, which
is handled as follows.  An input timestamp is compared with the expected
timestamp as dictated by input sample stream and if the deviation is less
than #GstAudioEncoder:tolerance, the deviation is discarded.
Otherwise, it is considered a discontuinity and subsequent output timestamp
is resynced to the new position after performing configured discontinuity
processing.  In the non-perfect-timestamp case, an upstream variation
exceeding tolerance only leads to marking DISCONT on subsequent outgoing
(while timestamps are adjusted to upstream regardless of variation).
While DISCONT is also marked in the perfect-timestamp case, this one
optionally (see #GstAudioEncoder:hard-resync)
performs some additional steps, such as clipping of (early) input samples
or draining all currently remaining input data, depending on the direction
of the discontuinity.

If perfect timestamps are arranged, it is also possible to request baseclass
(usually set by subclass) to provide additional buffer metadata (in OFFSET
and OFFSET_END) fields according to granule defined semantics currently
needed by oggmux.  Specifically, OFFSET is set to granulepos (= sample count
including buffer) and OFFSET_END to corresponding timestamp (as determined
by same sample count and sample rate).

Things that subclass need to take care of:
&lt;itemizedlist&gt;
  &lt;listitem&gt;&lt;para&gt;Provide pad templates&lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
     Set source pad caps when appropriate
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
     Inform base class of buffer processing needs using context's
     frame_samples and frame_bytes.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
     Set user-configurable properties to sane defaults for format and
     implementing codec at hand, e.g. those controlling timestamp behaviour
     and discontinuity processing.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
     Accept data in @handle_frame and provide encoded results to
     gst_audio_encoder_finish_frame().
  &lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
      <implements name="Gst.Preset"/>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="decide_allocation">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="flush">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="getcaps">
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_frame">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="negotiate" invoker="negotiate">
        <doc xml:space="preserve">Negotiate with downstream elements to currently configured #GstCaps.
Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if
negotiate fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#TRUE if the negotiation succeeded, else #FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="pre_push">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="propose_allocation">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_format">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="AudioInfo" c:type="GstAudioInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sink_event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="src_event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="allocate_output_buffer"
              c:identifier="gst_audio_encoder_allocate_output_buffer">
        <doc xml:space="preserve">Helper function that allocates a buffer to hold an encoded audio frame
for @enc's current output format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">allocated buffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">size of the buffer</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="finish_frame"
              c:identifier="gst_audio_encoder_finish_frame">
        <doc xml:space="preserve">Collects encoded data and pushes encoded data downstream.
Source pad caps must be set when this is called.

If @samples &lt; 0, then best estimate is all samples provided to encoder
(subclass) so far.  @buf may be NULL, in which case next number of @samples
are considered discarded, e.g. as a result of discontinuous transmission,
and a discontinuity is marked.

Note that samples received in gst_audio_encoder_handle_frame()
may be invalidated by a call to this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GstFlowReturn that should be escalated to caller (of caller)</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">encoded data</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="samples" transfer-ownership="none">
            <doc xml:space="preserve">number of samples (per channel) represented by encoded data</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_allocator"
              c:identifier="gst_audio_encoder_get_allocator">
        <doc xml:space="preserve">Lets #GstAudioEncoder sub-classes to know the memory @allocator
used by the base class and its @params.

Unref the @allocator after use it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="allocator"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">the #GstAllocator
used</doc>
            <type name="Gst.Allocator" c:type="GstAllocator**"/>
          </parameter>
          <parameter name="params"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">the
#GstAllocatorParams of @allocator</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_audio_info"
              c:identifier="gst_audio_encoder_get_audio_info">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GstAudioInfo describing the input audio format</doc>
          <type name="AudioInfo" c:type="GstAudioInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_drainable"
              c:identifier="gst_audio_encoder_get_drainable">
        <doc xml:space="preserve">Queries encoder drain handling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if drainable handling is enabled.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_frame_max"
              c:identifier="gst_audio_encoder_get_frame_max">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">currently configured maximum handled frames</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_frame_samples_max"
              c:identifier="gst_audio_encoder_get_frame_samples_max">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">currently maximum requested samples per frame</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_frame_samples_min"
              c:identifier="gst_audio_encoder_get_frame_samples_min">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">currently minimum requested samples per frame</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hard_min"
              c:identifier="gst_audio_encoder_get_hard_min">
        <doc xml:space="preserve">Queries encoder hard minimum handling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if hard minimum handling is enabled.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hard_resync"
              c:identifier="gst_audio_encoder_get_hard_resync">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_latency" c:identifier="gst_audio_encoder_get_latency">
        <doc xml:space="preserve">Sets the variables pointed to by @min and @max to the currently configured
latency.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="min"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">a pointer to storage to hold minimum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="max"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">a pointer to storage to hold maximum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_lookahead"
              c:identifier="gst_audio_encoder_get_lookahead">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">currently configured encoder lookahead</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mark_granule"
              c:identifier="gst_audio_encoder_get_mark_granule">
        <doc xml:space="preserve">Queries if the encoder will handle granule marking.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if granule marking is enabled.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_perfect_timestamp"
              c:identifier="gst_audio_encoder_get_perfect_timestamp">
        <doc xml:space="preserve">Queries encoder perfect timestamp behaviour.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if perfect timestamp setting enabled.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tolerance"
              c:identifier="gst_audio_encoder_get_tolerance">
        <doc xml:space="preserve">Queries current audio jitter tolerance threshold.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">encoder audio jitter tolerance threshold.

MT safe.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="merge_tags" c:identifier="gst_audio_encoder_merge_tags">
        <doc xml:space="preserve">Adds tags to so-called pending tags, which will be processed
before pushing out data downstream.

Note that this is provided for convenience, and the subclass is
not required to use this and can still do tag handling on its own,
although it should be aware that baseclass already takes care
of the usual CODEC/AUDIO_CODEC tags.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="tags" transfer-ownership="none">
            <doc xml:space="preserve">a #GstTagList to merge</doc>
            <type name="Gst.TagList" c:type="const GstTagList*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">the #GstTagMergeMode to use</doc>
            <type name="Gst.TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="negotiate" c:identifier="gst_audio_encoder_negotiate">
        <doc xml:space="preserve">Negotiate with downstream elements to currently configured #GstCaps.
Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if
negotiate fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#TRUE if the negotiation succeeded, else #FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="proxy_getcaps"
              c:identifier="gst_audio_encoder_proxy_getcaps">
        <doc xml:space="preserve">Returns caps that express @caps (or sink template caps if @caps == NULL)
restricted to channel/rate combinations supported by downstream elements
(e.g. muxers).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GstCaps owned by caller</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="caps"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">initial caps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="filter"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">filter caps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_drainable"
              c:identifier="gst_audio_encoder_set_drainable">
        <doc xml:space="preserve">Configures encoder drain handling.  If drainable, subclass might
be handed a NULL buffer to have it return any leftover encoded data.
Otherwise, it is not considered so capable and will only ever be passed
real data.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_frame_max"
              c:identifier="gst_audio_encoder_set_frame_max">
        <doc xml:space="preserve">Sets max number of frames accepted at once (assumed minimally 1).
Requires @frame_samples_min and @frame_samples_max to be the equal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="num" transfer-ownership="none">
            <doc xml:space="preserve">number of frames</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_frame_samples_max"
              c:identifier="gst_audio_encoder_set_frame_samples_max">
        <doc xml:space="preserve">Sets number of samples (per channel) subclass needs to be handed,
at most or will be handed all available if 0.

If an exact number of samples is required, gst_audio_encoder_set_frame_samples_min()
must be called with the same number.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="num" transfer-ownership="none">
            <doc xml:space="preserve">number of samples per frame</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_frame_samples_min"
              c:identifier="gst_audio_encoder_set_frame_samples_min">
        <doc xml:space="preserve">Sets number of samples (per channel) subclass needs to be handed,
at least or will be handed all available if 0.

If an exact number of samples is required, gst_audio_encoder_set_frame_samples_max()
must be called with the same number.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="num" transfer-ownership="none">
            <doc xml:space="preserve">number of samples per frame</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hard_min"
              c:identifier="gst_audio_encoder_set_hard_min">
        <doc xml:space="preserve">Configures encoder hard minimum handling.  If enabled, subclass
will never be handed less samples than it configured, which otherwise
might occur near end-of-data handling.  Instead, the leftover samples
will simply be discarded.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hard_resync"
              c:identifier="gst_audio_encoder_set_hard_resync">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_headers" c:identifier="gst_audio_encoder_set_headers">
        <doc xml:space="preserve">Set the codec headers to be sent downstream whenever requested.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="headers" transfer-ownership="full">
            <doc xml:space="preserve">a list of
  #GstBuffer containing the codec header</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Gst.Buffer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_latency" c:identifier="gst_audio_encoder_set_latency">
        <doc xml:space="preserve">Sets encoder latency.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="min" transfer-ownership="none">
            <doc xml:space="preserve">minimum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="max" transfer-ownership="none">
            <doc xml:space="preserve">maximum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_lookahead"
              c:identifier="gst_audio_encoder_set_lookahead">
        <doc xml:space="preserve">Sets encoder lookahead (in units of input rate samples)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="num" transfer-ownership="none">
            <doc xml:space="preserve">lookahead</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_mark_granule"
              c:identifier="gst_audio_encoder_set_mark_granule">
        <doc xml:space="preserve">Enable or disable encoder granule handling.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_output_format"
              c:identifier="gst_audio_encoder_set_output_format">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_perfect_timestamp"
              c:identifier="gst_audio_encoder_set_perfect_timestamp">
        <doc xml:space="preserve">Enable or disable encoder perfect output timestamp preference.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tolerance"
              c:identifier="gst_audio_encoder_set_tolerance">
        <doc xml:space="preserve">Configures encoder audio jitter tolerance threshold.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="tolerance" transfer-ownership="none">
            <doc xml:space="preserve">new tolerance</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <property name="hard-resync" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="mark-granule" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="perfect-timestamp"
                writable="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="tolerance" writable="1" transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <field name="element">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="sinkpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="srcpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="stream_lock">
        <type name="GLib.RecMutex" c:type="GRecMutex"/>
      </field>
      <field name="input_segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="output_segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AudioEncoderPrivate" c:type="GstAudioEncoderPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioEncoderClass"
            c:type="GstAudioEncoderClass"
            glib:is-gtype-struct-for="AudioEncoder">
      <doc xml:space="preserve">Subclasses can override any of the available virtual methods or not, as
needed. At minimum @set_format and @handle_frame needs to be overridden.</doc>
      <field name="element_class">
        <doc xml:space="preserve">The parent class structure</doc>
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_format">
        <callback name="set_format">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="AudioInfo" c:type="GstAudioInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handle_frame">
        <callback name="handle_frame">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flush">
        <callback name="flush">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pre_push">
        <callback name="pre_push">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sink_event">
        <callback name="sink_event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="src_event">
        <callback name="src_event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="getcaps">
        <callback name="getcaps">
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="filter" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="negotiate">
        <callback name="negotiate">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">#TRUE if the negotiation succeeded, else #FALSE.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <doc xml:space="preserve">a #GstAudioEncoder</doc>
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="decide_allocation">
        <callback name="decide_allocation">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="propose_allocation">
        <callback name="propose_allocation">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AudioEncoderPrivate"
            c:type="GstAudioEncoderPrivate"
            disguised="1">
    </record>
    <class name="AudioFilter"
           c:symbol-prefix="audio_filter"
           c:type="GstAudioFilter"
           parent="GstBase.BaseTransform"
           abstract="1"
           glib:type-name="GstAudioFilter"
           glib:get-type="gst_audio_filter_get_type"
           glib:type-struct="AudioFilterClass">
      <doc xml:space="preserve">#GstAudioFilter is a #GstBaseTransform&lt;!-- --&gt;-derived base class for simple audio
filters, ie. those that output the same format that they get as input.

#GstAudioFilter will parse the input format for you (with error checking)
before calling your setup function. Also, elements deriving from
#GstAudioFilter may use gst_audio_filter_class_add_pad_templates() from
their class_init function to easily configure the set of caps/formats that
the element is able to handle.

Derived classes should override the #GstAudioFilterClass.setup() and
#GstBaseTransformClass.transform_ip() and/or
#GstBaseTransformClass.transform()
virtual functions in their class_init function.</doc>
      <virtual-method name="setup">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <type name="AudioFilter" c:type="GstAudioFilter*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="AudioInfo" c:type="const GstAudioInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <field name="basetransform">
        <type name="GstBase.BaseTransform" c:type="GstBaseTransform"/>
      </field>
      <field name="info">
        <type name="AudioInfo" c:type="GstAudioInfo"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioFilterClass"
            c:type="GstAudioFilterClass"
            glib:is-gtype-struct-for="AudioFilter">
      <doc xml:space="preserve">In addition to the @setup virtual function, you should also override the
GstBaseTransform::transform and/or GstBaseTransform::transform_ip virtual
function.</doc>
      <field name="basetransformclass">
        <doc xml:space="preserve">parent class</doc>
        <type name="GstBase.BaseTransformClass"
              c:type="GstBaseTransformClass"/>
      </field>
      <field name="setup">
        <callback name="setup">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="filter" transfer-ownership="none">
              <type name="AudioFilter" c:type="GstAudioFilter*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="AudioInfo" c:type="const GstAudioInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="add_pad_templates"
              c:identifier="gst_audio_filter_class_add_pad_templates">
        <doc xml:space="preserve">Convenience function to add pad templates to this element class, with
@allowed_caps as the caps that can be handled.

This function is usually used from within a GObject class_init function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="klass" transfer-ownership="none">
            <doc xml:space="preserve">an #GstAudioFilterClass</doc>
            <type name="AudioFilterClass" c:type="GstAudioFilterClass*"/>
          </instance-parameter>
          <parameter name="allowed_caps" transfer-ownership="none">
            <doc xml:space="preserve">what formats the filter can handle, as #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="AudioFlags"
              glib:type-name="GstAudioFlags"
              glib:get-type="gst_audio_flags_get_type"
              c:type="GstAudioFlags">
      <doc xml:space="preserve">Extra audio flags</doc>
      <member name="none"
              value="0"
              c:identifier="GST_AUDIO_FLAG_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no valid flag</doc>
      </member>
      <member name="unpositioned"
              value="1"
              c:identifier="GST_AUDIO_FLAG_UNPOSITIONED"
              glib:nick="unpositioned">
        <doc xml:space="preserve">the position array explicitly
    contains unpositioned channels.</doc>
      </member>
    </bitfield>
    <enumeration name="AudioFormat"
                 glib:type-name="GstAudioFormat"
                 glib:get-type="gst_audio_format_get_type"
                 c:type="GstAudioFormat">
      <doc xml:space="preserve">Enum value describing the most common audio formats.</doc>
      <member name="unknown"
              value="0"
              c:identifier="GST_AUDIO_FORMAT_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown or unset audio format</doc>
      </member>
      <member name="encoded"
              value="1"
              c:identifier="GST_AUDIO_FORMAT_ENCODED"
              glib:nick="encoded">
        <doc xml:space="preserve">encoded audio format</doc>
      </member>
      <member name="s8"
              value="2"
              c:identifier="GST_AUDIO_FORMAT_S8"
              glib:nick="s8">
        <doc xml:space="preserve">8 bits in 8 bits, signed</doc>
      </member>
      <member name="u8"
              value="3"
              c:identifier="GST_AUDIO_FORMAT_U8"
              glib:nick="u8">
        <doc xml:space="preserve">8 bits in 8 bits, unsigned</doc>
      </member>
      <member name="s16le"
              value="4"
              c:identifier="GST_AUDIO_FORMAT_S16LE"
              glib:nick="s16le">
        <doc xml:space="preserve">16 bits in 16 bits, signed, little endian</doc>
      </member>
      <member name="s16be"
              value="5"
              c:identifier="GST_AUDIO_FORMAT_S16BE"
              glib:nick="s16be">
        <doc xml:space="preserve">16 bits in 16 bits, signed, big endian</doc>
      </member>
      <member name="u16le"
              value="6"
              c:identifier="GST_AUDIO_FORMAT_U16LE"
              glib:nick="u16le">
        <doc xml:space="preserve">16 bits in 16 bits, unsigned, little endian</doc>
      </member>
      <member name="u16be"
              value="7"
              c:identifier="GST_AUDIO_FORMAT_U16BE"
              glib:nick="u16be">
        <doc xml:space="preserve">16 bits in 16 bits, unsigned, big endian</doc>
      </member>
      <member name="s24_32le"
              value="8"
              c:identifier="GST_AUDIO_FORMAT_S24_32LE"
              glib:nick="s24-32le">
        <doc xml:space="preserve">24 bits in 32 bits, signed, little endian</doc>
      </member>
      <member name="s24_32be"
              value="9"
              c:identifier="GST_AUDIO_FORMAT_S24_32BE"
              glib:nick="s24-32be">
        <doc xml:space="preserve">24 bits in 32 bits, signed, big endian</doc>
      </member>
      <member name="u24_32le"
              value="10"
              c:identifier="GST_AUDIO_FORMAT_U24_32LE"
              glib:nick="u24-32le">
        <doc xml:space="preserve">24 bits in 32 bits, unsigned, little endian</doc>
      </member>
      <member name="u24_32be"
              value="11"
              c:identifier="GST_AUDIO_FORMAT_U24_32BE"
              glib:nick="u24-32be">
        <doc xml:space="preserve">24 bits in 32 bits, unsigned, big endian</doc>
      </member>
      <member name="s32le"
              value="12"
              c:identifier="GST_AUDIO_FORMAT_S32LE"
              glib:nick="s32le">
        <doc xml:space="preserve">32 bits in 32 bits, signed, little endian</doc>
      </member>
      <member name="s32be"
              value="13"
              c:identifier="GST_AUDIO_FORMAT_S32BE"
              glib:nick="s32be">
        <doc xml:space="preserve">32 bits in 32 bits, signed, big endian</doc>
      </member>
      <member name="u32le"
              value="14"
              c:identifier="GST_AUDIO_FORMAT_U32LE"
              glib:nick="u32le">
        <doc xml:space="preserve">32 bits in 32 bits, unsigned, little endian</doc>
      </member>
      <member name="u32be"
              value="15"
              c:identifier="GST_AUDIO_FORMAT_U32BE"
              glib:nick="u32be">
        <doc xml:space="preserve">32 bits in 32 bits, unsigned, big endian</doc>
      </member>
      <member name="s24le"
              value="16"
              c:identifier="GST_AUDIO_FORMAT_S24LE"
              glib:nick="s24le">
        <doc xml:space="preserve">24 bits in 24 bits, signed, little endian</doc>
      </member>
      <member name="s24be"
              value="17"
              c:identifier="GST_AUDIO_FORMAT_S24BE"
              glib:nick="s24be">
        <doc xml:space="preserve">24 bits in 24 bits, signed, big endian</doc>
      </member>
      <member name="u24le"
              value="18"
              c:identifier="GST_AUDIO_FORMAT_U24LE"
              glib:nick="u24le">
        <doc xml:space="preserve">24 bits in 24 bits, unsigned, little endian</doc>
      </member>
      <member name="u24be"
              value="19"
              c:identifier="GST_AUDIO_FORMAT_U24BE"
              glib:nick="u24be">
        <doc xml:space="preserve">24 bits in 24 bits, unsigned, big endian</doc>
      </member>
      <member name="s20le"
              value="20"
              c:identifier="GST_AUDIO_FORMAT_S20LE"
              glib:nick="s20le">
        <doc xml:space="preserve">20 bits in 24 bits, signed, little endian</doc>
      </member>
      <member name="s20be"
              value="21"
              c:identifier="GST_AUDIO_FORMAT_S20BE"
              glib:nick="s20be">
        <doc xml:space="preserve">20 bits in 24 bits, signed, big endian</doc>
      </member>
      <member name="u20le"
              value="22"
              c:identifier="GST_AUDIO_FORMAT_U20LE"
              glib:nick="u20le">
        <doc xml:space="preserve">20 bits in 24 bits, unsigned, little endian</doc>
      </member>
      <member name="u20be"
              value="23"
              c:identifier="GST_AUDIO_FORMAT_U20BE"
              glib:nick="u20be">
        <doc xml:space="preserve">20 bits in 24 bits, unsigned, big endian</doc>
      </member>
      <member name="s18le"
              value="24"
              c:identifier="GST_AUDIO_FORMAT_S18LE"
              glib:nick="s18le">
        <doc xml:space="preserve">18 bits in 24 bits, signed, little endian</doc>
      </member>
      <member name="s18be"
              value="25"
              c:identifier="GST_AUDIO_FORMAT_S18BE"
              glib:nick="s18be">
        <doc xml:space="preserve">18 bits in 24 bits, signed, big endian</doc>
      </member>
      <member name="u18le"
              value="26"
              c:identifier="GST_AUDIO_FORMAT_U18LE"
              glib:nick="u18le">
        <doc xml:space="preserve">18 bits in 24 bits, unsigned, little endian</doc>
      </member>
      <member name="u18be"
              value="27"
              c:identifier="GST_AUDIO_FORMAT_U18BE"
              glib:nick="u18be">
        <doc xml:space="preserve">18 bits in 24 bits, unsigned, big endian</doc>
      </member>
      <member name="f32le"
              value="28"
              c:identifier="GST_AUDIO_FORMAT_F32LE"
              glib:nick="f32le">
        <doc xml:space="preserve">32-bit floating point samples, little endian</doc>
      </member>
      <member name="f32be"
              value="29"
              c:identifier="GST_AUDIO_FORMAT_F32BE"
              glib:nick="f32be">
        <doc xml:space="preserve">32-bit floating point samples, big endian</doc>
      </member>
      <member name="f64le"
              value="30"
              c:identifier="GST_AUDIO_FORMAT_F64LE"
              glib:nick="f64le">
        <doc xml:space="preserve">64-bit floating point samples, little endian</doc>
      </member>
      <member name="f64be"
              value="31"
              c:identifier="GST_AUDIO_FORMAT_F64BE"
              glib:nick="f64be">
        <doc xml:space="preserve">64-bit floating point samples, big endian</doc>
      </member>
      <member name="s16"
              value="4"
              c:identifier="GST_AUDIO_FORMAT_S16"
              glib:nick="s16">
        <doc xml:space="preserve">16 bits in 16 bits, signed, native endianness</doc>
      </member>
      <member name="u16"
              value="6"
              c:identifier="GST_AUDIO_FORMAT_U16"
              glib:nick="u16">
        <doc xml:space="preserve">16 bits in 16 bits, unsigned, native endianness</doc>
      </member>
      <member name="s24_32"
              value="8"
              c:identifier="GST_AUDIO_FORMAT_S24_32"
              glib:nick="s24-32">
        <doc xml:space="preserve">24 bits in 32 bits, signed, native endianness</doc>
      </member>
      <member name="u24_32"
              value="10"
              c:identifier="GST_AUDIO_FORMAT_U24_32"
              glib:nick="u24-32">
        <doc xml:space="preserve">24 bits in 32 bits, unsigned, native endianness</doc>
      </member>
      <member name="s32"
              value="12"
              c:identifier="GST_AUDIO_FORMAT_S32"
              glib:nick="s32">
        <doc xml:space="preserve">32 bits in 32 bits, signed, native endianness</doc>
      </member>
      <member name="u32"
              value="14"
              c:identifier="GST_AUDIO_FORMAT_U32"
              glib:nick="u32">
        <doc xml:space="preserve">32 bits in 32 bits, unsigned, native endianness</doc>
      </member>
      <member name="s24"
              value="16"
              c:identifier="GST_AUDIO_FORMAT_S24"
              glib:nick="s24">
        <doc xml:space="preserve">24 bits in 24 bits, signed, native endianness</doc>
      </member>
      <member name="u24"
              value="18"
              c:identifier="GST_AUDIO_FORMAT_U24"
              glib:nick="u24">
        <doc xml:space="preserve">24 bits in 24 bits, unsigned, native endianness</doc>
      </member>
      <member name="s20"
              value="20"
              c:identifier="GST_AUDIO_FORMAT_S20"
              glib:nick="s20">
        <doc xml:space="preserve">20 bits in 24 bits, signed, native endianness</doc>
      </member>
      <member name="u20"
              value="22"
              c:identifier="GST_AUDIO_FORMAT_U20"
              glib:nick="u20">
        <doc xml:space="preserve">20 bits in 24 bits, unsigned, native endianness</doc>
      </member>
      <member name="s18"
              value="24"
              c:identifier="GST_AUDIO_FORMAT_S18"
              glib:nick="s18">
        <doc xml:space="preserve">18 bits in 24 bits, signed, native endianness</doc>
      </member>
      <member name="u18"
              value="26"
              c:identifier="GST_AUDIO_FORMAT_U18"
              glib:nick="u18">
        <doc xml:space="preserve">18 bits in 24 bits, unsigned, native endianness</doc>
      </member>
      <member name="f32"
              value="28"
              c:identifier="GST_AUDIO_FORMAT_F32"
              glib:nick="f32">
        <doc xml:space="preserve">32-bit floating point samples, native endianness</doc>
      </member>
      <member name="f64"
              value="30"
              c:identifier="GST_AUDIO_FORMAT_F64"
              glib:nick="f64">
        <doc xml:space="preserve">64-bit floating point samples, native endianness</doc>
      </member>
      <function name="build_integer"
                c:identifier="gst_audio_format_build_integer">
        <doc xml:space="preserve">Construct a #GstAudioFormat with given parameters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioFormat or GST_AUDIO_FORMAT_UNKNOWN when no audio format
exists with the given parameters.</doc>
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </return-value>
        <parameters>
          <parameter name="sign" transfer-ownership="none">
            <doc xml:space="preserve">signed or unsigned format</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="endianness" transfer-ownership="none">
            <doc xml:space="preserve">G_LITTLE_ENDIAN or G_BIG_ENDIAN</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">amount of bits used per sample</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="depth" transfer-ownership="none">
            <doc xml:space="preserve">amount of used bits in @width</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <function name="fill_silence"
                c:identifier="gst_audio_format_fill_silence">
        <doc xml:space="preserve">Fill @length bytes in @dest with silence samples for @info.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioFormatInfo</doc>
            <type name="AudioFormatInfo" c:type="const GstAudioFormatInfo*"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">a destination
  to fill</doc>
            <array length="2" zero-terminated="0" c:type="gpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length to fill</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <function name="from_string" c:identifier="gst_audio_format_from_string">
        <doc xml:space="preserve">Convert the @format string to its #GstAudioFormat.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GstAudioFormat for @format or GST_AUDIO_FORMAT_UNKNOWN when the
string is not a known format.</doc>
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_info" c:identifier="gst_audio_format_get_info">
        <doc xml:space="preserve">Get the #GstAudioFormatInfo for @format</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #GstAudioFormatInfo for @format.</doc>
          <type name="AudioFormatInfo" c:type="const GstAudioFormatInfo*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioFormat</doc>
            <type name="AudioFormat" c:type="GstAudioFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="to_string" c:identifier="gst_audio_format_to_string">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <type name="AudioFormat" c:type="GstAudioFormat"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <bitfield name="AudioFormatFlags"
              glib:type-name="GstAudioFormatFlags"
              glib:get-type="gst_audio_format_flags_get_type"
              c:type="GstAudioFormatFlags">
      <doc xml:space="preserve">The different audio flags that a format info can have.</doc>
      <member name="integer"
              value="1"
              c:identifier="GST_AUDIO_FORMAT_FLAG_INTEGER"
              glib:nick="integer">
        <doc xml:space="preserve">integer samples</doc>
      </member>
      <member name="float"
              value="2"
              c:identifier="GST_AUDIO_FORMAT_FLAG_FLOAT"
              glib:nick="float">
        <doc xml:space="preserve">float samples</doc>
      </member>
      <member name="signed"
              value="4"
              c:identifier="GST_AUDIO_FORMAT_FLAG_SIGNED"
              glib:nick="signed">
        <doc xml:space="preserve">signed samples</doc>
      </member>
      <member name="complex"
              value="16"
              c:identifier="GST_AUDIO_FORMAT_FLAG_COMPLEX"
              glib:nick="complex">
        <doc xml:space="preserve">complex layout</doc>
      </member>
      <member name="unpack"
              value="32"
              c:identifier="GST_AUDIO_FORMAT_FLAG_UNPACK"
              glib:nick="unpack">
        <doc xml:space="preserve">the format can be used in
#GstAudioFormatUnpack and #GstAudioFormatPack functions</doc>
      </member>
    </bitfield>
    <record name="AudioFormatInfo" c:type="GstAudioFormatInfo">
      <doc xml:space="preserve">Information for an audio format.</doc>
      <field name="format" writable="1">
        <doc xml:space="preserve">#GstAudioFormat</doc>
        <type name="AudioFormat" c:type="GstAudioFormat"/>
      </field>
      <field name="name" writable="1">
        <doc xml:space="preserve">string representation of the format</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="description" writable="1">
        <doc xml:space="preserve">user readable description of the format</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">#GstAudioFormatFlags</doc>
        <type name="AudioFormatFlags" c:type="GstAudioFormatFlags"/>
      </field>
      <field name="endianness" writable="1">
        <doc xml:space="preserve">the endianness</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="width" writable="1">
        <doc xml:space="preserve">amount of bits used for one sample</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="depth" writable="1">
        <doc xml:space="preserve">amount of valid bits in @width</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="silence" writable="1">
        <doc xml:space="preserve">@width/8 bytes with 1 silent sample</doc>
        <array zero-terminated="0" c:type="guint8" fixed-size="8">
          <type name="guint8" c:type="guint8"/>
        </array>
      </field>
      <field name="unpack_format" writable="1">
        <doc xml:space="preserve">the format of the unpacked samples</doc>
        <type name="AudioFormat" c:type="GstAudioFormat"/>
      </field>
      <field name="unpack_func" writable="1">
        <doc xml:space="preserve">function to unpack samples</doc>
        <type name="AudioFormatUnpack" c:type="GstAudioFormatUnpack"/>
      </field>
      <field name="pack_func" writable="1">
        <doc xml:space="preserve">function to pack samples</doc>
        <type name="AudioFormatPack" c:type="GstAudioFormatPack"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="AudioFormatPack" c:type="GstAudioFormatPack">
      <doc xml:space="preserve">Packs @length samples from @src to the data array in format @info.
The samples from source have each channel interleaved
and will be packed into @data.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioFormatInfo</doc>
          <type name="AudioFormatInfo" c:type="const GstAudioFormatInfo*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <type name="AudioPackFlags" c:type="GstAudioPackFlags"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">a source array</doc>
          <array zero-terminated="0" c:type="gpointer">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">pointer to the destination
  data</doc>
          <array zero-terminated="0" c:type="gpointer">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the amount of samples to pack.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="AudioFormatUnpack" c:type="GstAudioFormatUnpack">
      <doc xml:space="preserve">Unpacks @length samples from the given data of format @info.
The samples will be unpacked into @dest which each channel
interleaved. @dest should at least be big enough to hold @length *
channels * size(unpack_format) bytes.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioFormatInfo</doc>
          <type name="AudioFormatInfo" c:type="const GstAudioFormatInfo*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <type name="AudioPackFlags" c:type="GstAudioPackFlags"/>
        </parameter>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">a destination array</doc>
          <array zero-terminated="0" c:type="gpointer">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">pointer to the audio data</doc>
          <array zero-terminated="0" c:type="gpointer">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the amount of samples to unpack.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </callback>
    <record name="AudioInfo"
            c:type="GstAudioInfo"
            glib:type-name="GstAudioInfo"
            glib:get-type="gst_audio_info_get_type"
            c:symbol-prefix="audio_info">
      <doc xml:space="preserve">Information describing audio properties. This information can be filled
in from GstCaps with gst_audio_info_from_caps().

Use the provided macros to access the info in this structure.</doc>
      <field name="finfo" writable="1">
        <doc xml:space="preserve">the format info of the audio</doc>
        <type name="AudioFormatInfo" c:type="const GstAudioFormatInfo*"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">additional audio flags</doc>
        <type name="AudioFlags" c:type="GstAudioFlags"/>
      </field>
      <field name="layout" writable="1">
        <doc xml:space="preserve">audio layout</doc>
        <type name="AudioLayout" c:type="GstAudioLayout"/>
      </field>
      <field name="rate" writable="1">
        <doc xml:space="preserve">the audio sample rate</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="channels" writable="1">
        <doc xml:space="preserve">the number of channels</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="bpf" writable="1">
        <doc xml:space="preserve">the number of bytes for one frame, this is the size of one
        sample * @channels</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="position" writable="1">
        <doc xml:space="preserve">the positions for each channel</doc>
        <array zero-terminated="0"
               c:type="GstAudioChannelPosition"
               fixed-size="64">
          <type name="AudioChannelPosition" c:type="GstAudioChannelPosition"/>
        </array>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <constructor name="new" c:identifier="gst_audio_info_new">
        <doc xml:space="preserve">Allocate a new #GstAudioInfo that is also initialized with
gst_audio_info_init().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstAudioInfo. free with gst_audio_info_free().</doc>
          <type name="AudioInfo" c:type="GstAudioInfo*"/>
        </return-value>
      </constructor>
      <method name="convert" c:identifier="gst_audio_info_convert">
        <doc xml:space="preserve">Converts among various #GstFormat types.  This function handles
GST_FORMAT_BYTES, GST_FORMAT_TIME, and GST_FORMAT_DEFAULT.  For
raw audio, GST_FORMAT_DEFAULT corresponds to audio frames.  This
function can be used to handle pad queries of the type GST_QUERY_CONVERT.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the conversion was successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="const GstAudioInfo*"/>
          </instance-parameter>
          <parameter name="src_fmt" transfer-ownership="none">
            <doc xml:space="preserve">#GstFormat of the @src_val</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_val" transfer-ownership="none">
            <doc xml:space="preserve">value to convert</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_fmt" transfer-ownership="none">
            <doc xml:space="preserve">#GstFormat of the @dest_val</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="dest_val" transfer-ownership="none">
            <doc xml:space="preserve">pointer to destination value</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="gst_audio_info_copy">
        <doc xml:space="preserve">Copy a GstAudioInfo structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstAudioInfo. free with gst_audio_info_free.</doc>
          <type name="AudioInfo" c:type="GstAudioInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="const GstAudioInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_audio_info_free">
        <doc xml:space="preserve">Free a GstAudioInfo structure previously allocated with gst_audio_info_new()
or gst_audio_info_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="GstAudioInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="from_caps" c:identifier="gst_audio_info_from_caps">
        <doc xml:space="preserve">Parse @caps and update @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if @caps could be parsed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="GstAudioInfo*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:space="preserve">a #GstCaps</doc>
            <type name="Gst.Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gst_audio_info_init">
        <doc xml:space="preserve">Initialize @info with default values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="GstAudioInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_equal"
              c:identifier="gst_audio_info_is_equal"
              version="1.2">
        <doc xml:space="preserve">Compares two #GstAudioInfo and returns whether they are equal or not</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @info and @other are equal, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="const GstAudioInfo*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="const GstAudioInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_format" c:identifier="gst_audio_info_set_format">
        <doc xml:space="preserve">Set the default info for the audio info of @format and @rate and @channels.

Note: This initializes @info first, no values are preserved.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="GstAudioInfo*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the format</doc>
            <type name="AudioFormat" c:type="GstAudioFormat"/>
          </parameter>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:space="preserve">the samplerate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="channels" transfer-ownership="none">
            <doc xml:space="preserve">the number of channels</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the channel positions</doc>
            <type name="AudioChannelPosition"
                  c:type="const GstAudioChannelPosition*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_caps" c:identifier="gst_audio_info_to_caps">
        <doc xml:space="preserve">Convert the values of @info into a #GstCaps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GstCaps containing the
         info of @info.</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="const GstAudioInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="AudioLayout"
                 glib:type-name="GstAudioLayout"
                 glib:get-type="gst_audio_layout_get_type"
                 c:type="GstAudioLayout">
      <doc xml:space="preserve">Layout of the audio samples for the different channels.</doc>
      <member name="interleaved"
              value="0"
              c:identifier="GST_AUDIO_LAYOUT_INTERLEAVED"
              glib:nick="interleaved">
        <doc xml:space="preserve">interleaved audio</doc>
      </member>
      <member name="non_interleaved"
              value="1"
              c:identifier="GST_AUDIO_LAYOUT_NON_INTERLEAVED"
              glib:nick="non-interleaved">
        <doc xml:space="preserve">non-interleaved audio</doc>
      </member>
    </enumeration>
    <enumeration name="AudioPackFlags"
                 glib:type-name="GstAudioPackFlags"
                 glib:get-type="gst_audio_pack_flags_get_type"
                 c:type="GstAudioPackFlags">
      <doc xml:space="preserve">The different flags that can be used when packing and unpacking.</doc>
      <member name="none"
              value="0"
              c:identifier="GST_AUDIO_PACK_FLAG_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No flag</doc>
      </member>
    </enumeration>
    <class name="AudioRingBuffer"
           c:symbol-prefix="audio_ring_buffer"
           c:type="GstAudioRingBuffer"
           parent="Gst.Object"
           abstract="1"
           glib:type-name="GstAudioRingBuffer"
           glib:get-type="gst_audio_ring_buffer_get_type"
           glib:type-struct="AudioRingBufferClass">
      <doc xml:space="preserve">&lt;refsect2&gt;
&lt;para&gt;
This object is the base class for audio ringbuffers used by the base
audio source and sink classes.
&lt;/para&gt;
&lt;para&gt;
The ringbuffer abstracts a circular buffer of data. One reader and
one writer can operate on the data from different threads in a lockfree
manner. The base class is sufficiently flexible to be used as an
abstraction for DMA based ringbuffers as well as a pure software
implementations.
&lt;/para&gt;
&lt;/refsect2&gt;</doc>
      <function name="debug_spec_buff"
                c:identifier="gst_audio_ring_buffer_debug_spec_buff">
        <doc xml:space="preserve">Print debug info about the buffer sized in @spec to the debug log.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:space="preserve">the spec to debug</doc>
            <type name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec*"/>
          </parameter>
        </parameters>
      </function>
      <function name="debug_spec_caps"
                c:identifier="gst_audio_ring_buffer_debug_spec_caps">
        <doc xml:space="preserve">Print debug info about the parsed caps in @spec to the debug log.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:space="preserve">the spec to debug</doc>
            <type name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec*"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse_caps"
                c:identifier="gst_audio_ring_buffer_parse_caps">
        <doc xml:space="preserve">Parse @caps into @spec.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the caps could be parsed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:space="preserve">a spec</doc>
            <type name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec*"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:space="preserve">a #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="acquire" invoker="acquire">
        <doc xml:space="preserve">Allocate the resources for the ringbuffer. This function fills
in the data pointer of the ring buffer with a valid #GstBuffer
to which samples can be written.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be acquired, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to acquire</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:space="preserve">the specs of the buffer</doc>
            <type name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="activate" invoker="activate">
        <doc xml:space="preserve">Activate @buf to start or stop pulling data.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be activated in the requested mode,
FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to activate</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:space="preserve">the new mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="clear_all" invoker="clear_all">
        <doc xml:space="preserve">Fill the ringbuffer with silence.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to clear</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_device" invoker="close_device">
        <doc xml:space="preserve">Close the audio device associated with the ring buffer. The ring buffer
should already have been released via gst_audio_ring_buffer_release().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be closed, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="commit" invoker="commit">
        <doc xml:space="preserve">Commit @in_samples samples pointed to by @data to the ringbuffer @buf.

@in_samples and @out_samples define the rate conversion to perform on the
samples in @data. For negative rates, @out_samples must be negative and
@in_samples positive.

When @out_samples is positive, the first sample will be written at position @sample
in the ringbuffer. When @out_samples is negative, the last sample will be written to
@sample in reverse order.

@out_samples does not need to be a multiple of the segment size of the ringbuffer
although it is recommended for optimal performance.

@accum will hold a temporary accumulator used in rate conversion and should be
set to 0 when this function is first called. In case the commit operation is
interrupted, one can resume the processing by passing the previously returned
@accum value back to this function.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of samples written to the ringbuffer or -1 on error. The
number of samples written can be less than @out_samples when @buf was interrupted
with a flush or stop.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to commit</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="sample" transfer-ownership="none">
            <doc xml:space="preserve">the sample position of the data</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">the data to commit</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
          <parameter name="in_samples" transfer-ownership="none">
            <doc xml:space="preserve">the number of samples in the data to commit</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_samples" transfer-ownership="none">
            <doc xml:space="preserve">the number of samples to write to the ringbuffer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="accum" transfer-ownership="none">
            <doc xml:space="preserve">accumulator for rate conversion.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delay" invoker="delay">
        <doc xml:space="preserve">Get the number of samples queued in the audio device. This is
usually less than the segment size but can be bigger when the
implementation uses another internal buffer between the audio
device.

For playback ringbuffers this is the amount of samples transfered from the
ringbuffer to the device but still not played.

For capture ringbuffers this is the amount of samples in the device that are
not yet transfered to the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of samples queued in the audio device.

MT safe.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to query</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open_device" invoker="open_device">
        <doc xml:space="preserve">Open the audio device associated with the ring buffer. Does not perform any
setup on the device. You must open the device before acquiring the ring
buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be opened, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="pause" invoker="pause">
        <doc xml:space="preserve">Pause processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be paused, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to pause</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="release" invoker="release">
        <doc xml:space="preserve">Free the resources of the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be released, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to release</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="resume">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start" invoker="start">
        <doc xml:space="preserve">Start processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be started, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to start</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop" invoker="stop">
        <doc xml:space="preserve">Stop processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be stopped, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to stop</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="acquire" c:identifier="gst_audio_ring_buffer_acquire">
        <doc xml:space="preserve">Allocate the resources for the ringbuffer. This function fills
in the data pointer of the ring buffer with a valid #GstBuffer
to which samples can be written.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be acquired, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to acquire</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:space="preserve">the specs of the buffer</doc>
            <type name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="activate" c:identifier="gst_audio_ring_buffer_activate">
        <doc xml:space="preserve">Activate @buf to start or stop pulling data.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be activated in the requested mode,
FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to activate</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:space="preserve">the new mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="advance" c:identifier="gst_audio_ring_buffer_advance">
        <doc xml:space="preserve">Subclasses should call this function to notify the fact that
@advance segments are now processed by the device.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to advance</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="advance" transfer-ownership="none">
            <doc xml:space="preserve">the number of segments written</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="gst_audio_ring_buffer_clear">
        <doc xml:space="preserve">Clear the given segment of the buffer with silence samples.
This function is used by subclasses.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to clear</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">the segment to clear</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_all" c:identifier="gst_audio_ring_buffer_clear_all">
        <doc xml:space="preserve">Fill the ringbuffer with silence.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to clear</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="close_device"
              c:identifier="gst_audio_ring_buffer_close_device">
        <doc xml:space="preserve">Close the audio device associated with the ring buffer. The ring buffer
should already have been released via gst_audio_ring_buffer_release().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be closed, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="commit" c:identifier="gst_audio_ring_buffer_commit">
        <doc xml:space="preserve">Commit @in_samples samples pointed to by @data to the ringbuffer @buf.

@in_samples and @out_samples define the rate conversion to perform on the
samples in @data. For negative rates, @out_samples must be negative and
@in_samples positive.

When @out_samples is positive, the first sample will be written at position @sample
in the ringbuffer. When @out_samples is negative, the last sample will be written to
@sample in reverse order.

@out_samples does not need to be a multiple of the segment size of the ringbuffer
although it is recommended for optimal performance.

@accum will hold a temporary accumulator used in rate conversion and should be
set to 0 when this function is first called. In case the commit operation is
interrupted, one can resume the processing by passing the previously returned
@accum value back to this function.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of samples written to the ringbuffer or -1 on error. The
number of samples written can be less than @out_samples when @buf was interrupted
with a flush or stop.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to commit</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="sample" transfer-ownership="none">
            <doc xml:space="preserve">the sample position of the data</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">the data to commit</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
          <parameter name="in_samples" transfer-ownership="none">
            <doc xml:space="preserve">the number of samples in the data to commit</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_samples" transfer-ownership="none">
            <doc xml:space="preserve">the number of samples to write to the ringbuffer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="accum" transfer-ownership="none">
            <doc xml:space="preserve">accumulator for rate conversion.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="convert" c:identifier="gst_audio_ring_buffer_convert">
        <doc xml:space="preserve">Convert @src_val in @src_fmt to the equivalent value in @dest_fmt. The result
will be put in @dest_val.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the conversion succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="src_fmt" transfer-ownership="none">
            <doc xml:space="preserve">the source format</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_val" transfer-ownership="none">
            <doc xml:space="preserve">the source value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_fmt" transfer-ownership="none">
            <doc xml:space="preserve">the destination format</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="dest_val" transfer-ownership="none">
            <doc xml:space="preserve">a location to store the converted value</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delay" c:identifier="gst_audio_ring_buffer_delay">
        <doc xml:space="preserve">Get the number of samples queued in the audio device. This is
usually less than the segment size but can be bigger when the
implementation uses another internal buffer between the audio
device.

For playback ringbuffers this is the amount of samples transfered from the
ringbuffer to the device but still not played.

For capture ringbuffers this is the amount of samples in the device that are
not yet transfered to the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of samples queued in the audio device.

MT safe.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to query</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="device_is_open"
              c:identifier="gst_audio_ring_buffer_device_is_open">
        <doc xml:space="preserve">Checks the status of the device associated with the ring buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device was open, FALSE if it was closed.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_acquired"
              c:identifier="gst_audio_ring_buffer_is_acquired">
        <doc xml:space="preserve">Check if the ringbuffer is acquired and ready to use.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the ringbuffer is acquired, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to check</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_active" c:identifier="gst_audio_ring_buffer_is_active">
        <doc xml:space="preserve">Check if @buf is activated.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device is active.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_flushing"
              c:identifier="gst_audio_ring_buffer_is_flushing">
        <doc xml:space="preserve">Check if @buf is flushing.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device is flushing.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="may_start" c:identifier="gst_audio_ring_buffer_may_start">
        <doc xml:space="preserve">Tell the ringbuffer that it is allowed to start playback when
the ringbuffer is filled with samples.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="allowed" transfer-ownership="none">
            <doc xml:space="preserve">the new value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_device"
              c:identifier="gst_audio_ring_buffer_open_device">
        <doc xml:space="preserve">Open the audio device associated with the ring buffer. Does not perform any
setup on the device. You must open the device before acquiring the ring
buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be opened, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pause" c:identifier="gst_audio_ring_buffer_pause">
        <doc xml:space="preserve">Pause processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be paused, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to pause</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="prepare_read"
              c:identifier="gst_audio_ring_buffer_prepare_read">
        <doc xml:space="preserve">Returns a pointer to memory where the data from segment @segment
can be found. This function is mostly used by subclasses.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">FALSE if the buffer is not started.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to read from</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">the segment to read</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="readptr" transfer-ownership="none">
            <doc xml:space="preserve">the pointer to the memory where samples can be read</doc>
            <type name="guint8" c:type="guint8**"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to read</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="gst_audio_ring_buffer_read">
        <doc xml:space="preserve">Read @len samples from the ringbuffer into the memory pointed
to by @data.
The first sample should be read from position @sample in
the ringbuffer.

@len should not be a multiple of the segment size of the ringbuffer
although it is recommended.

@timestamp will return the timestamp associated with the data returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of samples read from the ringbuffer or -1 on
error.

MT safe.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to read from</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="sample" transfer-ownership="none">
            <doc xml:space="preserve">the sample position of the data</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">where the data should be read</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the number of samples in data to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:space="preserve">where the timestamp is returned</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="release" c:identifier="gst_audio_ring_buffer_release">
        <doc xml:space="preserve">Free the resources of the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be released, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to release</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="samples_done"
              c:identifier="gst_audio_ring_buffer_samples_done">
        <doc xml:space="preserve">Get the number of samples that were processed by the ringbuffer
since it was last started. This does not include the number of samples not
yet processed (see gst_audio_ring_buffer_delay()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of samples processed by the ringbuffer.

MT safe.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to query</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_callback"
              c:identifier="gst_audio_ring_buffer_set_callback">
        <doc xml:space="preserve">Sets the given callback function on the buffer. This function
will be called every time a segment has been written to a device.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to set the callback on</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="cb"
                     transfer-ownership="none"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">the callback to set</doc>
            <type name="AudioRingBufferCallback"
                  c:type="GstAudioRingBufferCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">user data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_channel_positions"
              c:identifier="gst_audio_ring_buffer_set_channel_positions">
        <doc xml:space="preserve">Tell the ringbuffer about the device's channel positions. This must
be called in when the ringbuffer is acquired.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the device channel positions</doc>
            <type name="AudioChannelPosition"
                  c:type="const GstAudioChannelPosition*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flushing"
              c:identifier="gst_audio_ring_buffer_set_flushing">
        <doc xml:space="preserve">Set the ringbuffer to flushing mode or normal mode.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to flush</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="flushing" transfer-ownership="none">
            <doc xml:space="preserve">the new mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sample"
              c:identifier="gst_audio_ring_buffer_set_sample">
        <doc xml:space="preserve">Make sure that the next sample written to the device is
accounted for as being the @sample sample written to the
device. This value will be used in reporting the current
sample position of the ringbuffer.

This function will also clear the buffer with silence.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to use</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="sample" transfer-ownership="none">
            <doc xml:space="preserve">the sample number to set</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_timestamp"
              c:identifier="gst_audio_ring_buffer_set_timestamp">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="readseg" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="gst_audio_ring_buffer_start">
        <doc xml:space="preserve">Start processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be started, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to start</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="stop" c:identifier="gst_audio_ring_buffer_stop">
        <doc xml:space="preserve">Stop processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be stopped, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to stop</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="cond">
        <doc xml:space="preserve">used to signal start/stop/pause/resume actions</doc>
        <type name="GLib.Cond" c:type="GCond"/>
      </field>
      <field name="open">
        <doc xml:space="preserve">boolean indicating that the ringbuffer is open</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="acquired">
        <doc xml:space="preserve">boolean indicating that the ringbuffer is acquired</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="memory">
        <doc xml:space="preserve">data in the ringbuffer</doc>
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="size">
        <doc xml:space="preserve">size of data in the ringbuffer</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="timestamps">
        <type name="Gst.ClockTime" c:type="GstClockTime*"/>
      </field>
      <field name="spec">
        <doc xml:space="preserve">format and layout of the ringbuffer data</doc>
        <type name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec"/>
      </field>
      <field name="samples_per_seg">
        <doc xml:space="preserve">number of samples in one segment</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="empty_seg">
        <doc xml:space="preserve">pointer to memory holding one segment of silence samples</doc>
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="state">
        <doc xml:space="preserve">state of the buffer</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="segdone">
        <doc xml:space="preserve">readpointer in the ringbuffer</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="segbase">
        <doc xml:space="preserve">segment corresponding to segment 0 (unused)</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="waiting">
        <doc xml:space="preserve">is a reader or writer waiting for a free segment</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="callback" readable="0" private="1">
        <type name="AudioRingBufferCallback"
              c:type="GstAudioRingBufferCallback"/>
      </field>
      <field name="cb_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="need_reorder" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="channel_reorder_map" readable="0" private="1">
        <array zero-terminated="0" c:type="gint" fixed-size="64">
          <type name="gint" c:type="gint"/>
        </array>
      </field>
      <field name="flushing" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="may_start" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="active" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <callback name="AudioRingBufferCallback"
              c:type="GstAudioRingBufferCallback">
      <doc xml:space="preserve">This function is set with gst_audio_ring_buffer_set_callback() and is
called to fill the memory at @data with @len bytes of samples.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="rbuf" transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioRingBuffer</doc>
          <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">target to fill</doc>
          <array length="2" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">amount to fill</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="AudioRingBufferClass"
            c:type="GstAudioRingBufferClass"
            glib:is-gtype-struct-for="AudioRingBuffer">
      <doc xml:space="preserve">The vmethods that subclasses can override to implement the ringbuffer.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">parent class</doc>
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="open_device">
        <callback name="open_device">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the device could be opened, FALSE on error.

MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="acquire">
        <callback name="acquire">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the device could be acquired, FALSE on error.

MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to acquire</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
            <parameter name="spec" transfer-ownership="none">
              <doc xml:space="preserve">the specs of the buffer</doc>
              <type name="AudioRingBufferSpec"
                    c:type="GstAudioRingBufferSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="release">
        <callback name="release">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the device could be released, FALSE on error.

MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to release</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_device">
        <callback name="close_device">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the device could be closed, FALSE on error.

MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the device could be started, FALSE on error.

MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to start</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pause">
        <callback name="pause">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the device could be paused, FALSE on error.

MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to pause</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="resume">
        <callback name="resume">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the device could be stopped, FALSE on error.

MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to stop</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delay">
        <callback name="delay">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The number of samples queued in the audio device.

MT safe.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to query</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="activate">
        <callback name="activate">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the device could be activated in the requested mode,
FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to activate</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
            <parameter name="active" transfer-ownership="none">
              <doc xml:space="preserve">the new mode</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="commit">
        <callback name="commit">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The number of samples written to the ringbuffer or -1 on error. The
number of samples written can be less than @out_samples when @buf was interrupted
with a flush or stop.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to commit</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
            <parameter name="sample" transfer-ownership="none">
              <doc xml:space="preserve">the sample position of the data</doc>
              <type name="guint64" c:type="guint64*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <doc xml:space="preserve">the data to commit</doc>
              <type name="guint8" c:type="guint8*"/>
            </parameter>
            <parameter name="in_samples" transfer-ownership="none">
              <doc xml:space="preserve">the number of samples in the data to commit</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="out_samples" transfer-ownership="none">
              <doc xml:space="preserve">the number of samples to write to the ringbuffer</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="accum" transfer-ownership="none">
              <doc xml:space="preserve">accumulator for rate conversion.</doc>
              <type name="gint" c:type="gint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="clear_all">
        <callback name="clear_all">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to clear</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="AudioRingBufferFormatType"
                 glib:type-name="GstAudioRingBufferFormatType"
                 glib:get-type="gst_audio_ring_buffer_format_type_get_type"
                 c:type="GstAudioRingBufferFormatType">
      <doc xml:space="preserve">The format of the samples in the ringbuffer.</doc>
      <member name="raw"
              value="0"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW"
              glib:nick="raw">
        <doc xml:space="preserve">samples in linear or float</doc>
      </member>
      <member name="mu_law"
              value="1"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MU_LAW"
              glib:nick="mu-law">
        <doc xml:space="preserve">samples in mulaw</doc>
      </member>
      <member name="a_law"
              value="2"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_A_LAW"
              glib:nick="a-law">
        <doc xml:space="preserve">samples in alaw</doc>
      </member>
      <member name="ima_adpcm"
              value="3"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IMA_ADPCM"
              glib:nick="ima-adpcm">
        <doc xml:space="preserve">samples in ima adpcm</doc>
      </member>
      <member name="mpeg"
              value="4"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG"
              glib:nick="mpeg">
        <doc xml:space="preserve">samples in mpeg audio (but not AAC) format</doc>
      </member>
      <member name="gsm"
              value="5"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_GSM"
              glib:nick="gsm">
        <doc xml:space="preserve">samples in gsm format</doc>
      </member>
      <member name="iec958"
              value="6"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IEC958"
              glib:nick="iec958">
        <doc xml:space="preserve">samples in IEC958 frames (e.g. AC3)</doc>
      </member>
      <member name="ac3"
              value="7"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_AC3"
              glib:nick="ac3">
        <doc xml:space="preserve">samples in AC3 format</doc>
      </member>
      <member name="eac3"
              value="8"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_EAC3"
              glib:nick="eac3">
        <doc xml:space="preserve">samples in EAC3 format</doc>
      </member>
      <member name="dts"
              value="9"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DTS"
              glib:nick="dts">
        <doc xml:space="preserve">samples in DTS format</doc>
      </member>
      <member name="mpeg2_aac"
              value="10"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC"
              glib:nick="mpeg2-aac">
        <doc xml:space="preserve">samples in MPEG-2 AAC format</doc>
      </member>
      <member name="mpeg4_aac"
              value="11"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC"
              glib:nick="mpeg4-aac">
        <doc xml:space="preserve">samples in MPEG-4 AAC format</doc>
      </member>
    </enumeration>
    <record name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec">
      <doc xml:space="preserve">The structure containing the format specification of the ringbuffer.</doc>
      <field name="caps" writable="1">
        <doc xml:space="preserve">The caps that generated the Spec.</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </field>
      <field name="type" writable="1">
        <doc xml:space="preserve">the sample type</doc>
        <type name="AudioRingBufferFormatType"
              c:type="GstAudioRingBufferFormatType"/>
      </field>
      <field name="info" writable="1">
        <doc xml:space="preserve">the #GstAudioInfo</doc>
        <type name="AudioInfo" c:type="GstAudioInfo"/>
      </field>
      <field name="latency_time" writable="1">
        <doc xml:space="preserve">the latency in microseconds</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="buffer_time" writable="1">
        <doc xml:space="preserve">the total buffer size in microseconds</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="segsize" writable="1">
        <doc xml:space="preserve">the size of one segment in bytes</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="segtotal" writable="1">
        <doc xml:space="preserve">the total number of segments</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="seglatency" writable="1">
        <doc xml:space="preserve">number of segments queued in the lower level device,
 defaults to segtotal</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="AudioRingBufferState"
                 glib:type-name="GstAudioRingBufferState"
                 glib:get-type="gst_audio_ring_buffer_state_get_type"
                 c:type="GstAudioRingBufferState">
      <doc xml:space="preserve">The state of the ringbuffer.</doc>
      <member name="stopped"
              value="0"
              c:identifier="GST_AUDIO_RING_BUFFER_STATE_STOPPED"
              glib:nick="stopped">
        <doc xml:space="preserve">The ringbuffer is stopped</doc>
      </member>
      <member name="paused"
              value="1"
              c:identifier="GST_AUDIO_RING_BUFFER_STATE_PAUSED"
              glib:nick="paused">
        <doc xml:space="preserve">The ringbuffer is paused</doc>
      </member>
      <member name="started"
              value="2"
              c:identifier="GST_AUDIO_RING_BUFFER_STATE_STARTED"
              glib:nick="started">
        <doc xml:space="preserve">The ringbuffer is started</doc>
      </member>
      <member name="error"
              value="3"
              c:identifier="GST_AUDIO_RING_BUFFER_STATE_ERROR"
              glib:nick="error">
        <doc xml:space="preserve">The ringbuffer has encountered an
    error after it has been started, e.g. because the device was
    disconnected (Since 1.2)</doc>
      </member>
    </enumeration>
    <class name="AudioSink"
           c:symbol-prefix="audio_sink"
           c:type="GstAudioSink"
           parent="AudioBaseSink"
           glib:type-name="GstAudioSink"
           glib:get-type="gst_audio_sink_get_type"
           glib:type-struct="AudioSinkClass">
      <doc xml:space="preserve">This is the most simple base class for audio sinks that only requires
subclasses to implement a set of simple functions:

&lt;variablelist&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;open()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Open the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;prepare()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Configure the device with the specified format.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;write()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Write samples to the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;reset()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Unblock writes and flush the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;delay()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Get the number of samples written but not yet played
    by the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;unprepare()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Undo operations done by prepare.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;close()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Close the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
&lt;/variablelist&gt;

All scheduling of samples and timestamps is done in this base class
together with #GstAudioBaseSink using a default implementation of a
#GstAudioRingBuffer that uses threads.</doc>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="AudioSink" c:type="GstAudioSink*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delay">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="AudioSink" c:type="GstAudioSink*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="AudioSink" c:type="GstAudioSink*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prepare">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="AudioSink" c:type="GstAudioSink*"/>
          </instance-parameter>
          <parameter name="spec" transfer-ownership="none">
            <type name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reset">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="AudioSink" c:type="GstAudioSink*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unprepare">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="AudioSink" c:type="GstAudioSink*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="AudioSink" c:type="GstAudioSink*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <field name="element">
        <type name="AudioBaseSink" c:type="GstAudioBaseSink"/>
      </field>
      <field name="thread" readable="0" private="1">
        <type name="GLib.Thread" c:type="GThread*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioSinkClass"
            c:type="GstAudioSinkClass"
            glib:is-gtype-struct-for="AudioSink">
      <doc xml:space="preserve">#GstAudioSink class. Override the vmethods to implement functionality.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class structure.</doc>
        <type name="AudioBaseSinkClass" c:type="GstAudioBaseSinkClass"/>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepare">
        <callback name="prepare">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
            <parameter name="spec" transfer-ownership="none">
              <type name="AudioRingBufferSpec"
                    c:type="GstAudioRingBufferSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unprepare">
        <callback name="unprepare">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write">
        <callback name="write">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delay">
        <callback name="delay">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reset">
        <callback name="reset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="AudioSrc"
           c:symbol-prefix="audio_src"
           c:type="GstAudioSrc"
           parent="AudioBaseSrc"
           glib:type-name="GstAudioSrc"
           glib:get-type="gst_audio_src_get_type"
           glib:type-struct="AudioSrcClass">
      <doc xml:space="preserve">This is the most simple base class for audio sources that only requires
subclasses to implement a set of simple functions:

&lt;variablelist&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;open()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Open the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;prepare()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Configure the device with the specified format.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;read()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Read samples from the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;reset()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Unblock reads and flush the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;delay()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Get the number of samples in the device but not yet read.
    &lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;unprepare()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Undo operations done by prepare.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;close()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Close the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
&lt;/variablelist&gt;

All scheduling of samples and timestamps is done in this base class
together with #GstAudioBaseSrc using a default implementation of a
#GstAudioRingBuffer that uses threads.</doc>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioSrc" c:type="GstAudioSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delay">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioSrc" c:type="GstAudioSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioSrc" c:type="GstAudioSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prepare">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioSrc" c:type="GstAudioSrc*"/>
          </instance-parameter>
          <parameter name="spec" transfer-ownership="none">
            <type name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioSrc" c:type="GstAudioSrc*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reset">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioSrc" c:type="GstAudioSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unprepare">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioSrc" c:type="GstAudioSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <field name="element">
        <type name="AudioBaseSrc" c:type="GstAudioBaseSrc"/>
      </field>
      <field name="thread" readable="0" private="1">
        <type name="GLib.Thread" c:type="GThread*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioSrcClass"
            c:type="GstAudioSrcClass"
            glib:is-gtype-struct-for="AudioSrc">
      <doc xml:space="preserve">#GstAudioSrc class. Override the vmethod to implement
functionality.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class.</doc>
        <type name="AudioBaseSrcClass" c:type="GstAudioBaseSrcClass"/>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepare">
        <callback name="prepare">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
            <parameter name="spec" transfer-ownership="none">
              <type name="AudioRingBufferSpec"
                    c:type="GstAudioRingBufferSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unprepare">
        <callback name="unprepare">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read">
        <callback name="read">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="timestamp" transfer-ownership="none">
              <type name="Gst.ClockTime" c:type="GstClockTime*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delay">
        <callback name="delay">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reset">
        <callback name="reset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <constant name="META_TAG_AUDIO_CHANNELS_STR"
              value="channels"
              c:type="GST_META_TAG_AUDIO_CHANNELS_STR"
              version="1.2">
      <doc xml:space="preserve">This metadata stays relevant as long as channels are unchanged.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_TAG_AUDIO_STR"
              value="audio"
              c:type="GST_META_TAG_AUDIO_STR"
              version="1.2">
      <doc xml:space="preserve">This metadata is relevant for audio streams.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <interface name="StreamVolume"
               c:symbol-prefix="stream_volume"
               c:type="GstStreamVolume"
               glib:type-name="GstStreamVolume"
               glib:get-type="gst_stream_volume_get_type"
               glib:type-struct="StreamVolumeInterface">
      <doc xml:space="preserve">&lt;refsect2&gt;
&lt;para&gt;
This interface is implemented by elements that provide a stream volume. Examples for
such elements are #volume and #playbin.
&lt;/para&gt;
&lt;para&gt;
Applications can use this interface to get or set the current stream volume. For this
the "volume" #GObject property can be used or the helper functions gst_stream_volume_set_volume()
and gst_stream_volume_get_volume(). This volume is always a linear factor, i.e. 0.0 is muted
1.0 is 100%. For showing the volume in a GUI it might make sense to convert it to
a different format by using gst_stream_volume_convert_volume(). Volume sliders should usually
use a cubic volume.

Separate from the volume the stream can also be muted by the "mute" #GObject property or
gst_stream_volume_set_mute() and gst_stream_volume_get_mute().
&lt;/para&gt;
&lt;para&gt;
Elements that provide some kind of stream volume should implement the "volume" and
"mute" #GObject properties and handle setting and getting of them properly.
The volume property is defined to be a linear volume factor.
&lt;/para&gt;
&lt;/refsect2&gt;</doc>
      <function name="convert_volume"
                c:identifier="gst_stream_volume_convert_volume">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the converted volume</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <parameter name="from" transfer-ownership="none">
            <doc xml:space="preserve">#GstStreamVolumeFormat to convert from</doc>
            <type name="StreamVolumeFormat" c:type="GstStreamVolumeFormat"/>
          </parameter>
          <parameter name="to" transfer-ownership="none">
            <doc xml:space="preserve">#GstStreamVolumeFormat to convert to</doc>
            <type name="StreamVolumeFormat" c:type="GstStreamVolumeFormat"/>
          </parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve">Volume in @from format that should be converted</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_mute" c:identifier="gst_stream_volume_get_mute">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Returns %TRUE if the stream is muted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">#GstStreamVolume that should be used</doc>
            <type name="StreamVolume" c:type="GstStreamVolume*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_volume" c:identifier="gst_stream_volume_get_volume">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current stream volume as linear factor</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">#GstStreamVolume that should be used</doc>
            <type name="StreamVolume" c:type="GstStreamVolume*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">#GstStreamVolumeFormat which should be returned</doc>
            <type name="StreamVolumeFormat" c:type="GstStreamVolumeFormat"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_mute" c:identifier="gst_stream_volume_set_mute">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">#GstStreamVolume that should be used</doc>
            <type name="StreamVolume" c:type="GstStreamVolume*"/>
          </instance-parameter>
          <parameter name="mute" transfer-ownership="none">
            <doc xml:space="preserve">Mute state that should be set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_volume" c:identifier="gst_stream_volume_set_volume">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">#GstStreamVolume that should be used</doc>
            <type name="StreamVolume" c:type="GstStreamVolume*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">#GstStreamVolumeFormat of @val</doc>
            <type name="StreamVolumeFormat" c:type="GstStreamVolumeFormat"/>
          </parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve">Linear volume factor that should be set</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <property name="mute" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="volume" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
    </interface>
    <enumeration name="StreamVolumeFormat" c:type="GstStreamVolumeFormat">
      <doc xml:space="preserve">Different representations of a stream volume. gst_stream_volume_convert_volume()
allows to convert between the different representations.

Formulas to convert from a linear to a cubic or dB volume are
cbrt(val) and 20 * log10 (val).</doc>
      <member name="linear"
              value="0"
              c:identifier="GST_STREAM_VOLUME_FORMAT_LINEAR">
        <doc xml:space="preserve">Linear scale factor, 1.0 = 100%</doc>
      </member>
      <member name="cubic"
              value="1"
              c:identifier="GST_STREAM_VOLUME_FORMAT_CUBIC">
        <doc xml:space="preserve">Cubic volume scale</doc>
      </member>
      <member name="db" value="2" c:identifier="GST_STREAM_VOLUME_FORMAT_DB">
        <doc xml:space="preserve">Logarithmic volume scale (dB, amplitude not power)</doc>
      </member>
    </enumeration>
    <record name="StreamVolumeInterface"
            c:type="GstStreamVolumeInterface"
            glib:is-gtype-struct-for="StreamVolume">
      <field name="iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
    </record>
    <function name="audio_buffer_clip" c:identifier="gst_audio_buffer_clip">
      <doc xml:space="preserve">Clip the buffer to the given %GstSegment.

After calling this function the caller does not own a reference to
@buffer anymore.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">%NULL if the buffer is completely outside the configured segment,
otherwise the clipped buffer is returned.

If the buffer has no timestamp, it is assumed to be inside the segment and
is not clipped</doc>
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="full">
          <doc xml:space="preserve">The buffer to clip.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="segment" transfer-ownership="none">
          <doc xml:space="preserve">Segment in %GST_FORMAT_TIME or %GST_FORMAT_DEFAULT to which
          the buffer should be clipped.</doc>
          <type name="Gst.Segment" c:type="GstSegment*"/>
        </parameter>
        <parameter name="rate" transfer-ownership="none">
          <doc xml:space="preserve">sample rate.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="bpf" transfer-ownership="none">
          <doc xml:space="preserve">size of one audio frame in bytes. This is the size of one sample
* channels.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_buffer_reorder_channels"
              c:identifier="gst_audio_buffer_reorder_channels">
      <doc xml:space="preserve">Reorders @buffer from the channel positions @from to the channel
positions @to. @from and @to must contain the same number of
positions and the same positions, only in a different order.
@buffer must be writable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the reordering was possible.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">The buffer to reorder.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">The %GstAudioFormat of the buffer.</doc>
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="from" transfer-ownership="none">
          <doc xml:space="preserve">The channel positions in the buffer.</doc>
          <array zero-terminated="0" c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="to" transfer-ownership="none">
          <doc xml:space="preserve">The channel positions to convert to.</doc>
          <array zero-terminated="0" c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="audio_channel_positions_from_mask"
              c:identifier="gst_audio_channel_positions_from_mask">
      <doc xml:space="preserve">Convert the @channels present in @channel_mask to a @position array
(which should have at least @channels entries ensured by caller).
If @channel_mask is set to 0, it is considered as 'not present' for purpose
of conversion.
A partially valid @channel_mask with less bits set than the number
of channels is considered valid.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if channel and channel mask are valid and could be converted</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="channel_mask" transfer-ownership="none">
          <doc xml:space="preserve">The input channel_mask</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="position" transfer-ownership="none">
          <doc xml:space="preserve">The
  %GstAudioChannelPosition&lt;!-- --&gt;s</doc>
          <array length="0"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="audio_channel_positions_to_mask"
              c:identifier="gst_audio_channel_positions_to_mask">
      <doc xml:space="preserve">Convert the @position array of @channels channels to a bitmask.

If @force_order is %TRUE it additionally checks if the channels are
in the order required by GStreamer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the channel positions are valid and could be converted.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="position" transfer-ownership="none">
          <doc xml:space="preserve">The %GstAudioChannelPositions</doc>
          <array length="1"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="force_order" transfer-ownership="none">
          <doc xml:space="preserve">Only consider the GStreamer channel order.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="channel_mask" transfer-ownership="none">
          <doc xml:space="preserve">the output channel mask</doc>
          <array zero-terminated="0" c:type="guint64*">
            <type name="guint64" c:type="guint64"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="audio_channel_positions_to_valid_order"
              c:identifier="gst_audio_channel_positions_to_valid_order">
      <doc xml:space="preserve">Reorders the channel positions in @position from any order to
the GStreamer channel order.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the channel positions are valid and reordering
was successful.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="position" transfer-ownership="none">
          <doc xml:space="preserve">The channel positions to
  reorder to.</doc>
          <array length="1"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_check_valid_channel_positions"
              c:identifier="gst_audio_check_valid_channel_positions">
      <doc xml:space="preserve">Checks if @position contains valid channel positions for
@channels channels. If @force_order is %TRUE it additionally
checks if the channels are in the order required by GStreamer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the channel positions are valid.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="position" transfer-ownership="none">
          <doc xml:space="preserve">The %GstAudioChannelPositions
  to check.</doc>
          <array length="1"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="force_order" transfer-ownership="none">
          <doc xml:space="preserve">Only consider the GStreamer channel order.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_downmix_meta_api_get_type"
              c:identifier="gst_audio_downmix_meta_api_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="audio_downmix_meta_get_info"
              c:identifier="gst_audio_downmix_meta_get_info"
              moved-to="AudioDownmixMeta.get_info">
      <return-value transfer-ownership="none">
        <type name="Gst.MetaInfo" c:type="const GstMetaInfo*"/>
      </return-value>
    </function>
    <function name="audio_format_build_integer"
              c:identifier="gst_audio_format_build_integer"
              moved-to="AudioFormat.build_integer">
      <doc xml:space="preserve">Construct a #GstAudioFormat with given parameters.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #GstAudioFormat or GST_AUDIO_FORMAT_UNKNOWN when no audio format
exists with the given parameters.</doc>
        <type name="AudioFormat" c:type="GstAudioFormat"/>
      </return-value>
      <parameters>
        <parameter name="sign" transfer-ownership="none">
          <doc xml:space="preserve">signed or unsigned format</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="endianness" transfer-ownership="none">
          <doc xml:space="preserve">G_LITTLE_ENDIAN or G_BIG_ENDIAN</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve">amount of bits used per sample</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="depth" transfer-ownership="none">
          <doc xml:space="preserve">amount of used bits in @width</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_format_fill_silence"
              c:identifier="gst_audio_format_fill_silence"
              moved-to="AudioFormat.fill_silence">
      <doc xml:space="preserve">Fill @length bytes in @dest with silence samples for @info.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioFormatInfo</doc>
          <type name="AudioFormatInfo" c:type="const GstAudioFormatInfo*"/>
        </parameter>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">a destination
  to fill</doc>
          <array length="2" zero-terminated="0" c:type="gpointer">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length to fill</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_format_from_string"
              c:identifier="gst_audio_format_from_string"
              moved-to="AudioFormat.from_string">
      <doc xml:space="preserve">Convert the @format string to its #GstAudioFormat.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GstAudioFormat for @format or GST_AUDIO_FORMAT_UNKNOWN when the
string is not a known format.</doc>
        <type name="AudioFormat" c:type="GstAudioFormat"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a format string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_format_get_info"
              c:identifier="gst_audio_format_get_info"
              moved-to="AudioFormat.get_info">
      <doc xml:space="preserve">Get the #GstAudioFormatInfo for @format</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The #GstAudioFormatInfo for @format.</doc>
        <type name="AudioFormatInfo" c:type="const GstAudioFormatInfo*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioFormat</doc>
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_format_info_get_type"
              c:identifier="gst_audio_format_info_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="audio_format_to_string"
              c:identifier="gst_audio_format_to_string"
              moved-to="AudioFormat.to_string">
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_get_channel_reorder_map"
              c:identifier="gst_audio_get_channel_reorder_map">
      <doc xml:space="preserve">Returns a reorder map for @from to @to that can be used in
custom channel reordering code, e.g. to convert from or to the
GStreamer channel order. @from and @to must contain the same
number of positions and the same positions, only in a
different order.

The resulting @reorder_map can be used for reordering by assigning
channel i of the input to channel reorder_map[i] of the output.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the channel positions are valid and reordering
is possible.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="from" transfer-ownership="none">
          <doc xml:space="preserve">The channel positions to reorder from.</doc>
          <array zero-terminated="0" c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="to" transfer-ownership="none">
          <doc xml:space="preserve">The channel positions to reorder to.</doc>
          <array zero-terminated="0" c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="reorder_map" transfer-ownership="none">
          <doc xml:space="preserve">Pointer to the reorder map.</doc>
          <array zero-terminated="0" c:type="gint*">
            <type name="gint" c:type="gint"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="audio_iec61937_frame_size"
              c:identifier="gst_audio_iec61937_frame_size">
      <doc xml:space="preserve">Calculated the size of the buffer expected by gst_audio_iec61937_payload() for
payloading type from @spec.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the size or 0 if the given @type is not supported or cannot be
payloaded.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="spec" transfer-ownership="none">
          <doc xml:space="preserve">the ringbufer spec</doc>
          <type name="AudioRingBufferSpec"
                c:type="const GstAudioRingBufferSpec*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_iec61937_payload"
              c:identifier="gst_audio_iec61937_payload">
      <doc xml:space="preserve">Payloads @src in the form specified by IEC 61937 for the type from @spec and
stores the result in @dst. @src must contain exactly one frame of data and
the frame is not checked for errors.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">transfer-full: %TRUE if the payloading was successful, %FALSE
otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">a buffer containing the data to payload</doc>
          <array length="1" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="src_n" transfer-ownership="none">
          <doc xml:space="preserve">size of @src in bytes</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="dst" transfer-ownership="none">
          <doc xml:space="preserve">the destination buffer to store the
      payloaded contents in. Should not overlap with @src</doc>
          <array length="3" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="dst_n" transfer-ownership="none">
          <doc xml:space="preserve">size of @dst in bytes</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="spec" transfer-ownership="none">
          <doc xml:space="preserve">the ringbufer spec for @src</doc>
          <type name="AudioRingBufferSpec"
                c:type="const GstAudioRingBufferSpec*"/>
        </parameter>
        <parameter name="endianness" transfer-ownership="none">
          <doc xml:space="preserve">the expected byte order of the payloaded data</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_reorder_channels"
              c:identifier="gst_audio_reorder_channels">
      <doc xml:space="preserve">Reorders @data from the channel positions @from to the channel
positions @to. @from and @to must contain the same number of
positions and the same positions, only in a different order.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the reordering was possible.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">The pointer to
  the memory.</doc>
          <array length="1" zero-terminated="0" c:type="gpointer">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">The size of the memory.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">The %GstAudioFormat of the buffer.</doc>
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="from" transfer-ownership="none">
          <doc xml:space="preserve">The channel positions in the buffer.</doc>
          <array zero-terminated="0" c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="to" transfer-ownership="none">
          <doc xml:space="preserve">The channel positions to convert to.</doc>
          <array zero-terminated="0" c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_add_audio_downmix_meta"
              c:identifier="gst_buffer_add_audio_downmix_meta">
      <doc xml:space="preserve">Attaches #GstAudioDownmixMeta metadata to @buffer with the given parameters.

@matrix is an two-dimensional array of @to_channels times @from_channels
coefficients, i.e. the i-th output channels is constructed by multiplicating
the input channels with the coefficients in @matrix[i] and taking the sum
of the results.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GstAudioDownmixMeta on @buffer.</doc>
        <type name="AudioDownmixMeta" c:type="GstAudioDownmixMeta*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">a #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="from_position" transfer-ownership="none">
          <doc xml:space="preserve">the channel positions
  of the source</doc>
          <array length="2"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="from_channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels of the source</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="to_position" transfer-ownership="none">
          <doc xml:space="preserve">the channel positions of
  the destination</doc>
          <array length="4"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="to_channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels of the destination</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:space="preserve">The matrix coefficients.</doc>
          <type name="gfloat" c:type="const gfloat**"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_get_audio_downmix_meta_for_channels"
              c:identifier="gst_buffer_get_audio_downmix_meta_for_channels">
      <doc xml:space="preserve">Find the #GstAudioDownmixMeta on @buffer for the given destination
channel positions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GstAudioDownmixMeta on @buffer.</doc>
        <type name="AudioDownmixMeta" c:type="GstAudioDownmixMeta*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">a #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="to_position" transfer-ownership="none">
          <doc xml:space="preserve">the channel positions of
  the destination</doc>
          <array length="2"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="to_channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels of the destination</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="stream_volume_convert_volume"
              c:identifier="gst_stream_volume_convert_volume"
              moved-to="StreamVolume.convert_volume">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the converted volume</doc>
        <type name="gdouble" c:type="gdouble"/>
      </return-value>
      <parameters>
        <parameter name="from" transfer-ownership="none">
          <doc xml:space="preserve">#GstStreamVolumeFormat to convert from</doc>
          <type name="StreamVolumeFormat" c:type="GstStreamVolumeFormat"/>
        </parameter>
        <parameter name="to" transfer-ownership="none">
          <doc xml:space="preserve">#GstStreamVolumeFormat to convert to</doc>
          <type name="StreamVolumeFormat" c:type="GstStreamVolumeFormat"/>
        </parameter>
        <parameter name="val" transfer-ownership="none">
          <doc xml:space="preserve">Volume in @from format that should be converted</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
